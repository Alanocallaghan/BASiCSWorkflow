---
title: "Supplementary material for: A BASiCS workflow for expression variability analysis using scRNA-Seq data"
author: 
  - name: Alan O'Callaghan
    affiliation: 
    - &MRC MRC Human Genetics Unit, Institute of Genetics \& Cancer, 
      University of Edinburgh, Western General Hospital, Crewe Road, Edinburgh, 
      EH4 2XU, UK
    email: "a.b.o'callaghan@sms.ed.ac.uk"
  - name: Nils Eling
    affiliation: 
    - &UZH Department of Quantitative Biomedicine, University of Zurich,
      Winterthurerstrasse 190, CH-8057, Zurich, Switzerland
    - &ETH Institute for Molecular Health Sciences, ETH Zurich,
      Otto-Stern Weg 7, 8093 Zurich, Switzerland
  - name: John C. Marioni
    affiliation: 
    - &EBI European Molecular Biology Laboratory, European Bioinformatics 
      Institute, Wellcome Trust Genome Campus, Hinxton, Cambridge CB10 1SD, UK
    - &CRUK Cancer Research UK Cambridge Institute, University of Cambridge, 
      Li Ka Shing Centre, Cambridge, CB2 0RE, UK
  - name: Catalina A. Vallejos
    affiliation: 
    - *MRC 
    - The Alan Turing Institute, British Library, 96 Euston Road, London, 
      NW1 2DB, UK
    email: catalina.vallejos@igmm.ed.ac.uk
bibliography: Workflow.bib
urlcolor: Orange
output:
  BiocWorkflowTools::f1000_article:
    fig_width: 6
    fig_height: 4
---


```{r setup_knitr, include = FALSE, cache = FALSE}
library("BiocStyle")
library("knitr")
knitr::opts_chunk$set(
  message = FALSE, error = FALSE, warning = FALSE,
  cache = 2, cache.path = "cache_supp/",
  fig.path = "figure_supp/"
)
```

# Methods

## The BASiCS model

The BASiCS package features a hierarchical Bayesian model in which the 
transcript count of gene $i$ of cell $j$ is represented as a random variable
$X_{ij}$. For all technical genes, counts can be modelled as Poisson distributed
with a random effect capturing unexplained technical noise:
$$
\begin{aligned}
  X_{ij}|\mu_i,\nu_j & \sim \text{Poisson}(\nu_j\mu_i)\\
  \nu_j|s_j,\theta & \sim \text{Gamma}\left(\frac{1}{\theta},\frac{1}{s_j\theta}\right)
\end{aligned}
$$
where $\mu_i$ explains the gene's mean expression, $\nu_j$ the technical effect
dominated by the mRNA capture efficiency $s_j$ and the unexplained technical 
noise parameter $\theta$. 

This technical influence effects all biological genes in the same manner. 
In addition to technical variations, cell-to-cell differences of biological 
gene expression can be cause by biological processes as explained above. 
To model an additional random effect that captures biological cell-to-cell 
variability, the random variable $X_{ij}$ is modelled as: 
$$
\begin{aligned}
  X_{ij}|\mu_i,\phi_j,\nu_j,\rho_{ij} & \sim \text{Poisson}(\phi_j\nu_j\mu_i\rho_{ij})\\
  \rho_{ij}|\delta_i & \sim \text{Gamma}(\frac{1}{\delta_i}, \frac{1}{\delta_i})
\end{aligned}
$$
where $\phi_j$ is the cell-specifc size factor and $\rho_{ij}$ the biological
random effect incorporating the over-dispersion hyper-parameter $\delta_i$.

In further analysis, $\mu_i$ represents the mean expression and $\delta_i$
the biological over-dispersion of each gene.

### Testing for changes in mean expression and over-dispersion

Differential mean and differential over-dispersion testing is done by computing
the tail posterior propabilities of the difference in mean expression or 
over-dispersion between two conditions ($A$ and $B$) being larger than an
evidence threshold $\tau_0$ or $\omega_0$ [@Bochkina2007, @Vallejos2016]:
$$
\begin{aligned}
  &\text{P}\left(\log\left(\frac{\mu_i^{(A)}}{\mu_i^{(B)}}\right) > \tau_0 | \text{Data}\right) > \alpha_m\\
  &\text{P}\left(\log\left(\frac{\delta_i^{(A)}}{\delta_i^{(B)}}\right) > \omega_0 | \text{Data}\right) > \alpha_d
\end{aligned}
$$

If the tail posterior probability is larger than a given propability threshold 
$\alpha_m$ or $\alpha_d$, the gene is considered to be differentially expressed
or differentially over-dispersed [@Vallejos2016]. The evidence threshold is
usually fixed *a priori* and the probability threshold is defined to
control the expected false discovery rate (EFDR) to 
(e.g. 10%) [@Newton2004, Vallejos2016].

As described by @Vallejos2016, estimates of the
over-dispersion parameters $\delta_i$ are negatively correlated to mean 
expression $\mu_i$. This indicates that in homogeneous populations of cells,
highly expressed genes tend to be less noisy than lowly expressed genes. 
Differential over-dispersion testing is therefore confounded by mean expression
changes. When assessing changes in over-dispersion $\delta_i$, only genes with
no changes in mean expression are considered (see @Vallejos2016).

### Correcting the mean-variability confounding effect

@Eling2018 extended BASiCS to account for the
confounding effect between mean expression and expression variability. 
For this purpose, we capture the relationship between mean and over-dispersion
parameters by introducing the following joint prior distribution for 
$(\mu_i, \delta_i)'$:
$$
  \mu_i \sim \text{log-Normal}\left(0, s^2_{\mu}\right), \hspace{0.5cm}
  \delta_i | \mu_i \sim \text{log-t}_{\eta}\left( \text{f}(\mu_i), \sigma^2 \right).
$$

The latter is equivalent to the non-linear regression model:
$$
  \log(\delta_i) = \text{f}(\mu_i) + \epsilon_i, \hspace{0.5cm} \epsilon_i \sim{}\text{t}_{\eta}(0,\sigma^2), 
$$

where $\mbox{f}(\mu_i)$ represents the over-dispersion (on the log-scale) that
is predicted by the global trend (across all genes) for a given mean expression 
$\mu_i$. Therefore, $\epsilon_i$ can be interpreted as a gene-specific 
*residual over-dispersion* parameter. Positive values for
$\epsilon_i$ indicate more variation than expected for genes with similar 
expression level. Similarly, negative values of $\epsilon_i$ suggest less 
variation than expected [@Eling2018].

In line with the probabilistic approach described above, we identified
statistically significant differences in residual over-dispersion for those 
genes where the tail posterior probability of observing a large difference 
between $\epsilon_i^A$ and $\epsilon_i^B$ exceeds a certain threshold:
$$
  \text{P}(\mid\epsilon_i^{A} - \epsilon_i^{B}\mid > \psi_0 \mid \text{Data}) > \alpha_R,
$$
where $\psi_0 > 0$ defines the minimum tolerance threshold. 
As a default choice, we assume $\psi_0 = \log_2(1.5) / \log_2(e) \approx 0.41$,
which translates into a 50\% increase in over-dispersion. 
The posterior probability threshold $\alpha_R$ is chosen to control the EFDR
(e.g. 10\%) [@Newton2004]. To support interpretability of the results,
we exclude genes that are not expressed in at least 2 cells per condition from
differential variability testing.

# Pre-processing and quality control steps for the mouse organogenesis dataset

The development of droplet-based scRNA-seq [@Klein2015;@Macosko2015] 
lead to a large increase in the number of cells that can be profiled per 
experiment at a fixed cost.
With this, large-scale scRNA-seq datasets have been generated to study 
development across multiple time-points and capturing multiple tissues 
[@Ibarra-Soria2018;@Kernfeld2018]. 
Here we describe the computational analysis of changes in mean expression 
and transcriptional variability when data are sparse and technical spike-in 
genes are missing. 
For this, we compare cells of the presomitic mesoderm and somitic mesoderm 
using droplet-based scRNA-seq data [@Ibarra-Soria2018].

## Loading necessary libraries

```{r libs}
library("SingleCellExperiment")
library("scater")
library("scran")
library("BASiCS")
library("ggplot2")
library("ggpointdensity")
library("biomaRt")
library("patchwork")
library("viridis")
## set default theme for plots
theme_set(theme_bw())
```

## Obtaining the data

The full dataset is stored under the accession number E-MTAB-6153 on 
ArrayExpress and can be obtained from [here](https://www.ebi.ac.uk/biostudies/arrayexpress/studies/E-MTAB-6153#). 
This workflows uses the *processed* data which consists of 3 files: 

- `rawCounts.tsv`: matrix of raw expression counts (UMI-based) for all genes
and cells.
- `cellAnnotation.tsv`: cell type labels identified by [@Ibarra-Soria2018].
- `normalisedCounts.tsv`: normalised expression counts obtained by 
[@Ibarra-Soria2018]. This file is **not** used in this workflow. 

*Of note:* The `.zip` file is 65 MB in size while the unzipped, raw counts 
measure 873 MB in size.

The code below downloads these as a compressed `.zip` file in the `downloads`
sub-folder. This is decompressed in order to access the individual `.tsv` files. 
After decompression, the `.zip` can be deleted as it is no longer required. 

```{r download-droplet-data}
options(timeout = 1000)
# Check whether the data was downloaded already
if (!file.exists("downloads/rawCounts.tsv")) {
  # Specifies data location
  website <- "https://www.ebi.ac.uk/"
  folder <- "arrayexpress/files/E-MTAB-6153/"
  file <- "E-MTAB-6153.processed.2.zip"
  # Data is downloaded in a `downloads` sub-folder
  download.file(
    paste0(website, folder, file),
    destfile = "downloads/rawCounts.zip"
  )
  # Un-compress the downloaded zip file 
  unzip(zipfile = "downloads/rawCounts.zip", exdir = "downloads")
  # Delete zip file as not longer required
  file.remove("downloads/rawCounts.zip")
}
```

We then load the raw read counts. 

```{r load-droplet-data-raw}
raw_counts <- read.delim("downloads/rawCounts.tsv", header = TRUE)
```

Prior to using BASiCS, it is important to perform quality control to remove 
poor quality cells and to control for potential heterogeneous substructure 
within the population of cells under study. In this case, [@Ibarra-Soria2018]
has already characterised population structure using clustering techniques. 
Here, we will use such information in order to define the cell populations to
be use as the input for BASiCS. 

The cluster labels identified in the original publication are then loaded:

```{r cluster-labels-droplet}
cluster_labels <- read.table("downloads/cellAnnotation.tsv",
  sep = "\t", header = TRUE, stringsAsFactors = FALSE)
```

The data contains the `r length(unique(cluster_labels$cellType))` cell types
identified by the authors. The number of cells per cluster is displayed below:

```{r table-cluster-labels-droplet}
table(cluster_labels$cellType, useNA = "ifany")
```

Cluster labels are not available for `r sum(is.na(cluster_labels$cellType))` cells. 

Note that the authors also identified some sub-structure within these main clusters:

```{r table-subclusters}
cluster_labels$subCellType <- sub("_.*", "", cluster_labels$cell)
table(cluster_labels$subCellType, cluster_labels$cellType)
```

Finally, we also note that the data also contains information about the three
samples from which the cells were extracted. This information can help us to
visualise potential batch effects.

```{r table-batch}
cluster_labels$sample <- as.factor(cluster_labels$sample)
table(cluster_labels$sample)
```

The authors integrated the data from these three samples using the cellranger
aggr program, which uses downsampling to generate samples with similar depth. 

## Select populations of interest

We selected the somitic 
($n = $ `r sum(cluster_labels$cellType == "somiticMesoderm", na.rm = TRUE)`) and 
pre-somitic mesoderm 
($n = $ `r sum(cluster_labels$cellType == "presomiticMesoderm", na.rm = TRUE)`)
cells. This is an arbitrary choice for illustration purposes only. The steps
of this workflow could be applied to any other pair of cell types. 

```{r droplet-cell-selection}
# Identifies which cells are in the groups of interest
ind_som <- which(cluster_labels$cellType == "somiticMesoderm" |
                 cluster_labels$cellType == "presomiticMesoderm")
# Selects the cells of interest from the raw counts and cluster-label metadata
raw_counts <- raw_counts[, ind_som]
cluster_labels <- cluster_labels[ind_som, ]
```

## Generating SingleCellExperiment object 

For pre-processing and visualisation purposes, we load the data into a 
`SingleCellExperiment` object. The metadata will be stored in the `colData` slot.

```{r droplet-sce}
droplet_sce <- SingleCellExperiment(
  assays = list(counts = as(as.matrix(raw_counts), "dgCMatrix")),
  colData = cluster_labels
  )
# Delete the original table of raw expression counts as no longer needed
rm(raw_counts)
```

## Annotation

Input data was annotated using Ensembl gene identifiers. 
To facilitate interpretation, it is often useful to obtain a mapping from 
Ensembl gene IDs to gene symbols using the BioMart suite
([http://www.biomart.org](http://www.biomart.org)) via the 
Bioconductor package `r Biocpkg("biomaRt")` [@Durinck2009].
This can also be used to obtain gene-pathways mappings and other
metadata (e.g. gene length), useful for performing functional analysis
of gene sets identified in downstream analyses.

```{r obtain-gene-symbols}
if (!dir.exists("rds")) {
  dir.create("rds", showWarnings = FALSE)
}
if (!file.exists("rds/genenames.rds")) {
  # Initialize mart and dataset
  ensembl <- useEnsembl(
    biomart = "genes",
    version = 104,
    dataset = "mmusculus_gene_ensembl"
  )
  # Select gene ID and gene name
  genenames <- getBM(
    attributes = c("ensembl_gene_id", "external_gene_name", "gene_biotype"),
    mart = ensembl
  )
  rownames(genenames) <- genenames$ensembl_gene_id
  saveRDS(genenames, "rds/genenames.rds")
}
genenames <- readRDS("rds/genenames.rds")
```

We add this information as `rowData` within the `SingleCellExperiment` 
object created above. 

```{r}
## Merge biomaRt annotation
rowdata <- data.frame(ensembl_gene_id = rownames(droplet_sce))
rowdata <- merge(rowdata, genenames, by = "ensembl_gene_id", all.x = TRUE)
rownames(rowdata) <- rowdata$ensembl_gene_id
# Sort to match the order in the original data
rowdata <- rowdata[rownames(droplet_sce),]
## Check if  order is correct after merge;
stopifnot(all(rownames(rowdata) == rownames(droplet_sce)))
## add to the SingleCellExperiment object
rowData(droplet_sce) <- rowdata
```

For the remaining analysis, we will only focus on the 
`r format(sum(rowData(droplet_sce)$gene_biotype == "protein_coding", na.rm=TRUE), big.mark=",")`
protein coding genes that are contained in the data. These are selected below. 

```{r}
protein_coding <- which(
  rowData(droplet_sce)$gene_biotype == "protein_coding"
)
droplet_sce <- droplet_sce[protein_coding, ]
```

## QC and exploratory data analysis

In order to perform quality control (QC), we calculate some cell-specific
summary statistics: the total number of counts per cell (`sum`) and the total 
number of detected genes per cell (`detected`). These will be added in the
`colData` slot. 

```{r cellqc-metrics}
droplet_sce <- addPerCellQC(droplet_sce)
```

The distribution of these metrics per each cluster can be visualised as follows:

```{r cellqc-metrics, fig.cap="Cell-level QC metrics. For each cell cluster: distribution of the total number of UMIs per cell (left) and the total number of detected genes per cell (right)."}
p_cell_qc1 <- plotColData(droplet_sce, y = "sum", x = "subCellType") 
p_cell_qc2 <- plotColData(droplet_sce, y = "detected", x = "subCellType")

p_cell_qc1 + p_cell_qc2
```
As seen in Figure \ref(fig:cellqc-metrics), the  `presomiticMesoderm.b` cluster 
is characterised by a substantially larger number of UMIs and detected genes. 
These have been highlighted by the authors as potential doublets. As in the 
original publication, these will be removed from subsequent analyses. We also 
remove cells with more 25,000 UMIs. 

```{r drop-filt}
ind_retain <- colData(droplet_sce)$subCellType != "presomiticMesoderm.b" &
  colData(droplet_sce)$sum <= 25000
droplet_sce <- droplet_sce[, ind_retain]
```

After applying this filter, the dataset contains `r ncol(droplet_sce)` cells:
`r sum(colData(droplet_sce)$subCellType == "presomiticMesoderm.a")` in the 
presomitic Mesoderm group and 
`r sum(colData(droplet_sce)$subCellType == "somiticMesoderm")` in the somitic
Mesoderm group. 

<!--- We removed all cells that expressed <1,000 genes or that had >3% of their 
transcripts mapped to mitochondrial genes. We further removed any cells that 
expressed both Xist and any of Kdm5d, Eif2s3y, Gm29650, Uty or Ddx3y (genes in 
the Y chromosome), as these are probably doublets. ---> 

To further explore the underlying structure of the data, we perform global
scaling normalisation using `r Biocpkg("scran")` and
principal component analysis (PCA) of log-transformed normalised expression 
counts using `r Biocpkg("scater")`.
As seen in Figure \@ref(fig:pca-visualisation-stimulus-batch), this analysis 
suggests the absence of strong batch effects.
It should be noted that the estimation of global scaling normalisation factors 
using `r Biocpkg("scran")` is not strictly necessary in the 
`r Biocpkg("BASiCS")` workflow. 
Here, we only use it as part of the exploratory data analysis. 
Moreover, count-based models for dimensionality reduction 
(e.g. [@Townes2019;@Lopez2018]) could be used as an alternative to PCA, 
removing the need for log normalisation.

```{r pca-visualisation-mesoderm-batch, fig.cap="First two principal components of log-transformed expression counts after scran normalisation. Colour indicates the experimental condition (left), the number of detected genes (middle) and animal of origin (right) for each cell."}
## Global scaling normalisation + log tranformation + PCA
droplet_sce <- computeSumFactors(droplet_sce, colData(droplet_sce)$subCellType)
droplet_sce <- logNormCounts(droplet_sce)
droplet_sce <- runPCA(droplet_sce)
p_type <- plotPCA(droplet_sce, ncomponents = c(2, 1), colour_by = "subCellType") +
  theme(legend.position = "bottom")
p_detected <- plotPCA(droplet_sce, ncomponents = c(2, 1), colour_by = "detected") +
  theme(legend.position = "bottom")
p_batch <- plotPCA(droplet_sce, ncomponents = c(2, 1), colour_by = "sample") +
  theme(legend.position = "bottom")
p_type + p_detected  + p_batch 
```
As seen inn Figure \ref(fig:pca-visualisation-mesoderm-batch), the first 
principal component (which explains approximately 9\%
of the total variability) captures the presomitic versus somitic Mesoderm
structure of the data. The second principal component (which explains 
approximately 3\% of the total variability) is correlated with the number of
detected features per cell. We do not observe substantial batch effects
driven by the animal of origin from which cells were collected. 

In addition to cell-specific QC, we also recommend a gene filtering 
step prior to using `r Biocpkg("BASiCS")`. 
The purpose of this filter is to remove lowly expressed genes that were largely
undetected through sequencing, making reliable variability estimates difficult
to obtain.
Here, we remove genes that are not detected in at least 20 cells across all 
cells. This is to ensure a reliable estimate of variability, roughly in line 
with the sample size requirements for the negative binomial distribution 
outlined in @Lloyd-Smith2007.


```{r gene-selection, fig.cap="Average UMI-count for each gene is plotted against the number of cells in which that gene was detected. Dashed grey lines are shown at the thresholds below which genes are removed."}
droplet_sce <- addPerFeatureQC(droplet_sce, exprs_values = "counts")
## Remove genes with zero total counts across all cells
droplet_sce <- droplet_sce[rowData(droplet_sce)$detected != 0, ]

## Transform "detected" into number of cells and define inclusion criteria
rowData(droplet_sce)$detected_cells <-
  rowData(droplet_sce)$detected * ncol(droplet_sce) / 100

detected_threshold <- 20
rowData(droplet_sce)$include_gene <- 
  rowData(droplet_sce)$detected_cells >= detected_threshold
plotRowData(
    droplet_sce,
    x = "detected_cells",
    y = "mean",
    colour_by = "include_gene"
  ) +
  xlab("Number of cells in which expression was detected") +
  ylab("Average number of read counts across all cells") +
  scale_x_log10() +
  scale_y_log10() +
  theme(legend.position = "bottom") +
  geom_vline(
    xintercept = detected_threshold,
    linetype = "dashed",
    col = "grey60"
  )

## Apply gene filter
droplet_sce <- droplet_sce[rowData(droplet_sce)$include_gene, ]
```

The final dataset used in subsequent analyses contains 
`r ncol(droplet_sce)` cells and `r nrow(droplet_sce)` genes.

```{r save-SCE}
saveRDS(droplet_sce, "rds/droplet_sce.rds")
```

## Generating the input data for BASiCS

Since droplet-based scRNA-seq data are generated without including technical 
spike-in genes, BASiCS uses measurement error models to quantify technical 
variation through replication [@Carroll1998].
Here, it is crucial to provide batch information to the BASiCS model.
In the case of the somitic and pre-somoitic mesoderm cells, embryos of two mice 
have been used to generate the data. 
Cells isolated from the first embryo were split into two batches and processed 
independently. These three different groups of cells are used as batches. 

To enable BASiCS to use this information, this should be stored as `BatchInfo`
within the `colData` slot. 

```{r BASiCS-droplet-data}
colData(droplet_sce)$BatchInfo  <- colData(droplet_sce)$sample
```

Before running the MCMC, we now separate cells into two groups: presomitic
mesoderm (PSM) and somitic mesoderm (SM)


```{r }  
sce_psm <- droplet_sce[, colData(droplet_sce)$cellType == "presomiticMesoderm",]
sce_sm <- droplet_sce[, colData(droplet_sce)$cellType == "somiticMesoderm",]

saveRDS(sce_psm, "rds/sce_psm.rds")
saveRDS(sce_sm, "rds/sce_sm.rds")
```

## Running the MCMC

We next estimate model parameters by running the MCMC cell-type specifically. 
Due to the high cell number ('r ncol(sce_psm)` for the pre-somitic mesoderm and 
'r ncol(sce_sm)` for the somitic mesoderm), we set the number of iterations to 20000. 

```{r run-mcmc, eval = FALSE}
set.seed(42)
chain_sm <- BASiCS_MCMC(
  Data = sce_sm,
  N = 20000,
  Thin = 10,
  Burn = 10000,
  Regression = TRUE,
  WithSpikes = FALSE,
  PriorParam = BASiCS_PriorParam(sce_sm, PriorMu = "EmpiricalBayes"),
  Threads = 4,
  StoreChains = TRUE,
  StoreDir = "rds/",
  RunName = "SM"
)
set.seed(43)
chain_psm <- BASiCS_MCMC(
  Data = sce_psm,
  N = 20000,
  Thin = 10,
  Burn = 10000,
  Regression = TRUE,
  WithSpikes = FALSE,
  PriorParam = BASiCS_PriorParam(sce_psm, PriorMu = "EmpiricalBayes"),
  Threads = 4,
  StoreChains = TRUE,
  StoreDir = "rds/",
  RunName = "PSM"
)
```

These chains took between 2.5 and 3 hours using an Intel 4770k (3.9 GHz,
32 GB RAM, using 4 threads). Here, we provide these chains to download from:

```{r droplet-chain-download}
chains_website <- "https://zenodo.org/record/5243265/files/"
options(timeout = 1000)
if (!file.exists("rds/chain_SM.Rds")) {
  download.file(
    paste0(chains_website, "chain_SM.Rds"),
    destfile = "rds/chain_SM.Rds"
  )
}
if (!file.exists("rds/chain_PSM.Rds")) {
  download.file(
    paste0(chains_website, "chain_PSM.Rds"),
    destfile = "rds/chain_PSM.Rds"
  )
}
chain_sm <- readRDS("rds/chain_SM.Rds")
chain_psm <- readRDS("rds/chain_PSM.Rds")
```

## Validating the model fit

Next, we visualise the results of the MCMC sampler by visualizing the 
different chains and by plotting the regression trend.
To assess whether the chains converged, we will visualise trace plots for some 
of the parameters. 
The `plot` function allows us to generate trace, posterior density,
and autocorrelation plots for different parameters.

```{r psm-chain-convergence, fig.cap = "Trace plot, marginal density, and autocorrelation function for mean expression of an example gene; presomatic cells."}
plot(chain_psm, Param = "mu", Gene = 120)
```

```{r sm-chain-convergence, fig.cap = "Trace plot, marginal density, and autocorrelation function for mean expression of an example gene; somatic cells."}
plot(chain_sm, Param = "mu", Gene = 120)
```


```{r diag-psm, fig.cap="MCMC diagnostics for gene-specific mean expression parameters; presomatic cells. A: Geweke Z-score for mean expression parameters is plotted against mean expression estimates. Dashed lines represent absolute Z-scores of 3, outside of which we advise caution when interpreting results. B: Effective sample size (ESS) is plotted against mean expression estimates. A dashed line shows a threshold of 100, below which we advise caution when interpreting results."}
diag_p1 <- BASiCS_DiagPlot(chain_psm, Measure = "geweke")
diag_p1 <- diag_p1 +
  geom_hline(yintercept = c(-3, 3), col = "firebrick", linetype = "dashed") +
  theme(legend.position = "none")

diag_p2 <- BASiCS_DiagPlot(chain_psm, Measure = "ess")
diag_p2 <- diag_p2 +
  geom_hline(yintercept = 100, col = "firebrick", linetype = "dashed") +
  theme(legend.position = "none")

diag_p1 + diag_p2 + plot_annotation(tag_levels = "A")
```


```{r diag-sm, fig.cap="MCMC diagnostics for gene-specific mean expression parameters; somatic cells. A: Geweke Z-score for mean expression parameters is plotted against mean expression estimates. Dashed lines represent absolute Z-scores of 3, outside of which we advise caution when interpreting results. B: Effective sample size (ESS) is plotted against mean expression estimates. A dashed line shows a threshold of 100, below which we advise caution when interpreting results."}
diag_p1 <- BASiCS_DiagPlot(chain_sm, Measure = "geweke")
diag_p1 <- diag_p1 +
  geom_hline(yintercept = c(-3, 3), col = "firebrick", linetype = "dashed") +
  theme(legend.position = "none")

diag_p2 <- BASiCS_DiagPlot(chain_sm, Measure = "ess")
diag_p2 <- diag_p2 +
  geom_hline(yintercept = 100, col = "firebrick", linetype = "dashed") +
  theme(legend.position = "none")

diag_p1 + diag_p2 + plot_annotation(tag_levels = "A")
```

We observe that the chains for all chosen parameters appear to have converged. 
Furthermore, to validate that the model fitted the mean-variability trend 
correctly, we plot posterior estimates for over-dispersion paramters $\delta_i$ 
against posterior estimates of mean expression parameters $\mu_i$.
For this, the `BASiCS_ShowFit` function can be used.

```{r droplet-regression-trend-psm, fig.cap="Over-dispersion is plotted against mean expression for all genes in pre-somitic mesoderm cells (A) and somitic mesoderm cells (B), on a log-log scale. Colour corresponds to local density, with lighter colours representing higher density. The curve represents the inferred trend of over-dispersion against mean, and the shaded area indicates the 95\\% credible interval."}
a <- BASiCS_ShowFit(chain_psm)
b <- BASiCS_ShowFit(chain_sm)

a + b + plot_annotation(tag_levels = "A")
```

Both trends display similar behaviour which allows us to compare residual 
over-dispersion estimates.

## Differential testing 

Next, we test for changes in mean expression and expression variability 
between the somitic and pre-somitic mesoderm.
First, we are interested in assessing global changes in expression 
variability between the two conditions.
For this, we compare over-dispersion parameters $\delta_i$ for genes that are
similarly expressed in both conditions.

```{r drop_testde_lfc0}
Droplet_Test_logFC0 <- BASiCS_TestDE(
  Chain1 = chain_psm,
  Chain2 = chain_sm,
  EpsilonM = 0,
  GroupLabel1 = "PSM",
  GroupLabel2 = "SM",
  Plot = FALSE,
  PlotOffset = FALSE,
  CheckESS = TRUE,
  MinESS = 100
)
```

```{r droplet-tested-boxplot, fig.cap="Boxplot of log over-dispersion parameters in pre-somitic and somitic mesoderm cells, respectively."}
DropletTableDisp <- as.data.frame(
  Droplet_Test_logFC0,
  Parameter = "Disp",
  Filter = FALSE
)
not_excluded <- DropletTableDisp$ResultDiffDisp != "ExcludedFromTesting"
for_plot <- DropletTableDisp[not_excluded, c("Disp1", "Disp2")]
for_plot <- reshape2::melt(for_plot)
ggplot(for_plot, aes(variable, log(value))) +
  geom_violin() +
  geom_boxplot(width = 0.25) +
  scale_x_discrete(labels = c("PSM", "SM")) +
  ylab("log(delta)") + xlab("")
```

### Global changes in variability

With this analysis, we do not detect global changes in expression variability.
We next profile changes in mean expression and expression variability on a 
gene-specific level.
For this, we use a log~2~ fold change threshold of 1 for mean expression testing 
and the default threshold of $\psi_0\approx0.41$ for differential variability 
testing.

```{r droplet-gene-specific-testing, fig.cap="Fold changes of average expression in presomitic mesoderm cells relative to somitic mesoderm cells are plotted again mean expression. Colour indicates genes that were excluded from differential expression test, and those with significantly higher mean expression in either group."}
Droplet_Test <- BASiCS_TestDE(
  Chain1 = chain_psm,
  Chain2 = chain_sm,
  EpsilonM = 1,
  GroupLabel1 = "PSM",
  GroupLabel2 = "SM",
  Plot = FALSE,
  PlotOffset = FALSE,
  CheckESS = TRUE,
  MinESS = 100
)

BASiCS_PlotDE(Droplet_Test, Parameter = "Mean", Plot = "MA")
Droplet_TableMean <- as.data.frame(
  Droplet_Test,
  Parameter = "Mean",
  Filter = FALSE
)
```

```{r droplet-gene-specific-testing-resdisp, fig.cap="Differences in residual over-dispersion parameters in presomitic mesoderm cells relative to somitic mesoderm cells are plotted again mean expression. Colour indicates genes that were excluded from differential expression test, and those with significantly higher residual over-dispersion in either group."}
Droplet_TableResDisp <- as.data.frame(
  Droplet_Test,
  Parameter = "ResDisp",
  Filter = FALSE
)
BASiCS_PlotDE(Droplet_Test, Parameter = "ResDisp", Plot = "MA")
```

### Differential mean expression

We can now list the genes that were detected as differentially expressed and 
differentially variable ordered by their difference in mean 
expression/variability.

```{r gene-lists-mean}
genenames <- readRDS("rds/genenames.rds")
## Highly expressed in somitic mesoderm
ind_sm <- Droplet_TableMean$ResultDiffMean == "SM+"
SM_mean <- Droplet_TableMean[ind_sm, ]
SM_mean <- SM_mean[order(SM_mean$MeanLog2FC, decreasing = FALSE), ]
SM_mean$Symbol <- genenames[SM_mean$GeneName, 2]

## Highly expressed in pre-somitic mesoderm
ind_psm <- Droplet_TableMean$ResultDiffMean == "PSM+"
PSM_mean <- Droplet_TableMean[ind_psm, ]
PSM_mean <- PSM_mean[order(PSM_mean$MeanLog2FC, decreasing = TRUE), ]
PSM_mean$Symbol <- genenames[PSM_mean$GeneName, 2]
```

We could then analyse the differentially expressed genes as performed
in the main text, or using
functional enrichment analysis as with other differential expression analysis
packages.
