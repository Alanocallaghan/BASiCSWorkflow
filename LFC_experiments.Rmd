---
title: "Experimentsabout posterior LCF distribution"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Here, I assume that the posterior distribution for each LFC parameter $\tau_i$ 
is normally distributed, with mean $m$ and standard deviation $s$. 

## Estimating the tail posterior probability based on a finite sample size


```{r}
MyProb_n <- function(nRep, n, m, s, lfc2_threhold) {
  
  est_prob <- rep(0, nRep)

  for(i in seq_len(nRep)){
     # Generating a random sample of size n
    x <- rnorm(n, mean = m, sd = s)
  
    # Inferred probability 
    est_prob[i] <- mean(abs(x) > lfc2_threhold)  
  }
  
  # Two tailed test, so this is the sum of two probabilities
  prob1 <- pnorm(-lfc2_threhold, mean = m, sd = s)
  prob2 <- 1 - pnorm(lfc2_threhold, mean = m, sd = s)
  true_prob <- prob1 + prob2
  
  list("est_prob" = est_prob, "true_prob" = true_prob)  
}

out1 <- MyProb_n(100, n =  500, m = 0, s = 1, lfc2_threhold = log2(1.5))
out2 <- MyProb_n(100, n = 1000, m = 0, s = 1, lfc2_threhold = log2(1.5))
out3 <- MyProb_n(100, n = 1500, m = 0, s = 1, lfc2_threhold = log2(1.5))
out4 <- MyProb_n(100, n = 2000, m = 0, s = 1, lfc2_threhold = log2(1.5))
out5 <- MyProb_n(100, n = 2500, m = 0, s = 1, lfc2_threhold = log2(1.5))
out6 <- MyProb_n(100, n = 5000, m = 0, s = 1, lfc2_threhold = log2(1.5))
out7 <- MyProb_n(100, n = 10000, m = 0, s = 1, lfc2_threhold = log2(1.5))

boxplot(cbind(out1$est_prob, out2$est_prob, out3$est_prob, 
              out4$est_prob, out5$est_prob, out6$est_prob, out7$est_prob), 
        names = c(500, 1000, 1500, 2000, 2500, 5000, 10000), 
        main = "Standard deviation = 1")
abline(h = out1$true_prob, col = "red")

out1 <- MyProb_n(100, n =  500, m = 0, s = 2, lfc2_threhold = log2(1.5))
out2 <- MyProb_n(100, n = 1000, m = 0, s = 2, lfc2_threhold = log2(1.5))
out3 <- MyProb_n(100, n = 1500, m = 0, s = 2, lfc2_threhold = log2(1.5))
out4 <- MyProb_n(100, n = 2000, m = 0, s = 2, lfc2_threhold = log2(1.5))
out5 <- MyProb_n(100, n = 2500, m = 0, s = 2, lfc2_threhold = log2(1.5))
out6 <- MyProb_n(100, n = 5000, m = 0, s = 2, lfc2_threhold = log2(1.5))
out7 <- MyProb_n(100, n = 10000, m = 0, s = 2, lfc2_threhold = log2(1.5))

boxplot(cbind(out1$est_prob, out2$est_prob, out3$est_prob, 
              out4$est_prob, out5$est_prob, out6$est_prob, out7$est_prob), 
        names = c(500, 1000, 1500, 2000, 2500, 5000, 10000), 
        main = "Standard deviation = 2")
abline(h = out1$true_prob, col = "red")
```

The simulations above suggest that estimating tail posterior probabilities 
based on a limited number of MCMC draws is subject to uncertainty. 

## Tail posterior probability based versus posterior sd


```{r}
MyProb <- function(n, m, s, lfc2_threhold) {
  
  # Generating a random sample of size n
  x <- rnorm(n, mean = m, sd = s)
  
  # Inferred probability 
  est_prob <- mean(abs(x) > lfc2_threhold)  
  
  # Two tailed test, so this is the sum of two probabilities
  prob1 <- pnorm(-lfc2_threhold, mean = m, sd = s)
  prob2 <- 1 - pnorm(lfc2_threhold, mean = m, sd = s)
  true_prob <- prob1 + prob2

  list("est_prob" = est_prob, "true_prob" = true_prob)  
}

MyProb(n = 1000, m = 0, s = 1, lfc2_threhold = log2(1.5))
MyProb(n = 1000, m = 0.5, s = 1.5, lfc2_threhold = log2(1.5))


out1 <- MyProb_n(100, n =  500, m = 0, s = 1, lfc2_threhold = log2(1.5))
out2 <- MyProb_n(100, n = 1000, m = 0, s = 1, lfc2_threhold = log2(1.5))
out3 <- MyProb_n(100, n = 1500, m = 0, s = 1, lfc2_threhold = log2(1.5))
out4 <- MyProb_n(100, n = 2000, m = 0, s = 1, lfc2_threhold = log2(1.5))
out5 <- MyProb_n(100, n = 2500, m = 0, s = 1, lfc2_threhold = log2(1.5))
out6 <- MyProb_n(100, n = 5000, m = 0, s = 1, lfc2_threhold = log2(1.5))
out7 <- MyProb_n(100, n = 10000, m = 0, s = 1, lfc2_threhold = log2(1.5))

boxplot(cbind(out1$est_prob, out2$est_prob, out3$est_prob, 
              out4$est_prob, out5$est_prob, out6$est_prob, out7$est_prob), 
        names = c(500, 1000, 1500, 2000, 2500, 5000, 10000), 
        main = "Standard deviation = 1")
abline(h = out1$true_prob, col = "red")

out1 <- MyProb_n(100, n =  500, m = 0, s = 2, lfc2_threhold = log2(1.5))
out2 <- MyProb_n(100, n = 1000, m = 0, s = 2, lfc2_threhold = log2(1.5))
out3 <- MyProb_n(100, n = 1500, m = 0, s = 2, lfc2_threhold = log2(1.5))
out4 <- MyProb_n(100, n = 2000, m = 0, s = 2, lfc2_threhold = log2(1.5))
out5 <- MyProb_n(100, n = 2500, m = 0, s = 2, lfc2_threhold = log2(1.5))
out6 <- MyProb_n(100, n = 5000, m = 0, s = 2, lfc2_threhold = log2(1.5))
out7 <- MyProb_n(100, n = 10000, m = 0, s = 2, lfc2_threhold = log2(1.5))

boxplot(cbind(out1$est_prob, out2$est_prob, out3$est_prob, 
              out4$est_prob, out5$est_prob, out6$est_prob, out7$est_prob), 
        names = c(500, 1000, 1500, 2000, 2500, 5000, 10000), 
        main = "Standard deviation = 2")
abline(h = out1$true_prob, col = "red")
```


```{r}
MCMC.naive <- readRDS(file = url("https://jmlab-gitlab.cruk.cam.ac.uk/publications/BASiCSWorkflow2018/raw/master/MCMCs/MCMC_naive.rds"))
MCMC.active <- readRDS(file = url("https://jmlab-gitlab.cruk.cam.ac.uk/publications/BASiCSWorkflow2018/raw/master/MCMCs/MCMC_active.rds"))

Summary.naive <- Summary(MCMC.naive)
Summary.active <- Summary(MCMC.active)

plot(displaySummaryBASiCS(Summary.naive, Param = "mu")[,1],
     displaySummaryBASiCS(Summary.active, Param = "mu")[,1], log = "xy")

smoothScatter(log(displaySummaryBASiCS(Summary.naive, Param = "mu")[,1]),
              log(displaySummaryBASiCS(Summary.active, Param = "mu")[,1]))


Chain.Average <- (displayChainBASiCS(MCMC.naive, Param = "mu") +
                    displayChainBASiCS(MCMC.active, Param = "mu")) / 2
Chain.LFC <- log2(displayChainBASiCS(MCMC.naive, Param = "mu") /
  displayChainBASiCS(MCMC.active, Param = "mu"))

Median.Average <- colMedians(Chain.Average)
Median.LFC <- colMedians(Chain.LFC)

Sd.LFC <- sqrt(colVars(Chain.LFC))

plot(Median.LFC, Sd.LFC)

smoothScatter(log(Median.Average), Median.LFC)

Test <- BASiCS_TestDE(MCMC.naive, MCMC.active, 
                      EFDR_M = 0.05, EFDR_D = 0.1, EFDR_R = 0.1, 
                      EpsilonM = log2(1.5),
                      EpsilonD = log2(1.5), EpsilonR = log2(1.5)/log2(exp(1)),
                      GroupLabel1 = "Naive", GroupLabel2 = "Active", 
                      Plot = TRUE, PlotOffset = TRUE)

plot(Test$TableMean$MeanLog2FC, Test$TableMean$ProbDiffMean)

with(Test$TableMean[log(Test$TableMean$MeanOverall) < 2,], 
     smoothScatter(log(MeanOverall), MeanLog2FC))

Table1 <- Test$TableMean[which(abs(Test$TableMean$MeanLog2FC) < log2(1.5) & Test$TableMean$ResultDiffMean != "NoDiff"),]

hist(Chain.LFC[,25])

hist(log(Median.Average))
```
