---
title: "A BASiCS workflow for expression variability analysis using scRNA-Seq data"
author:
- name: Nils Eling
  affiliation: 
  - &EBI European Molecular Biology Laboratory, European Bioinformatics Institute (EMBL-EBI), Wellcome Trust Genome Campus, Hinxton, Cambridge CB10 1SD, UK
  - &CRUK Cancer Research UK Cambridge Institute, University of Cambridge, Li Ka Shing Centre, Cambridge, CB2 0RE, UK
- name: John C. Marioni
  affiliation: 
  - *EBI
  - *CRUK
- name: Catalina A. Vallejos
  affiliation: 
  - The Alan Turing Institute, British Library, 96 Euston Road, London NW1 2DB, UK
  - Department of Statistical Science, University College London, 1-19 Torrington Place, London WC1E 7HB, UK
  email: INSERT.EMAIL
abstract: Heterogeneity in cellular responses is an inherent feature of biological systems. Stochastic and deterministic differences between individual cells on the transcriptional level introduce expression variability in cell populations. Single-cell RNA sequencing (scRNA-Seq) has been introduced to quantify expression variability across hundreds to thousands of cells.While scRNA-Seq is prone to high degrees of technical noise, the addition of external spike-in RNA or repetitions of experiments can be used to quantify technical noise. Here, we introduce a computational workflow to quantify and test for changes in biological variability in gene expression from scRNA-Seq data using the BASiCS package. The outlined analysis highlights possible confounding effects on variability measures, such as expression level and technical noise, and gives detailed analysis how to avoid these confounders. Furthermore, we exemplify analsyses of a dataset containing spike-in genes, such as data generated using the Fluidigm\@ C1 system, as well as a droplet-based dataset for which reads of spike-in RNA is not available. We will first introduce simple analyses to find highly and lowly variable genes, decompose the overall variability into a technical and biological part while later on focus on testing changes in mean expression and expression variability. The later allows the detection of global as well as gene-specific changes in variability and we exemplify a comparison that reveals heterogeneously induced genes hinting at possible, early cell fate commitment processes.  

#Abstracts should be up to 300 words and provide a succinct summary of the article. Although the abstract should explain why the article might be interesting, care should be taken not to inappropriately over-emphasise the importance of the work described in the article. Citations should not be used in the abstract, and the use of abbreviations should be minimized.
keywords: Single-cell RNA sequencing, expression variability, noise, differential expression testing
bibliography: BASiCSworkflow.bib
output: BiocWorkflowTools::f1000_article
#output:
# BiocStyle::html_document:
#   fig_caption: true
#   self_contained: yes
#vignette: >
#  %\VignetteIndexEntry{A BASiCS workflow for expression variability analysis using scRNAseq data}
#  %\VignetteEngine{knitr::rmarkdown}
#  %\VignetteEncoding{UTF-8}
---

```{r setup_knitr, include = FALSE, cache = FALSE}
#library(BiocStyle)
## Decide whether to display parts for BioC (TRUE) or F1000 (FALSE)
#on.bioc <- TRUE
#library(knitr)
# Use fig.width = 7 for html and fig.width = 6 for pdf
#fig.width <- ifelse(on.bioc, 7, 6)
#knitr::opts_chunk$set(cache = 2, warning = FALSE, message = FALSE, error = FALSE,
#  cache.path = "cache/", fig.path = "figure/", fig.width = fig.width)
```

# Introduction

Single-cell RNA-sequencing (scRNA-Seq) is the leading technology to study transcriptional heterogeneity in cellular subpopulations that remains undetected in bulk experiments [@Stegle2015]. 
Its applications range from studying cell types in immunity [@Lonnberg2017, @Villani2017] and development [@Ibarra-Soria2018a, @Wagner2018] to dissecting the mechanism for cell-to-cell differences in expression [@Goolam2016] or understanding differentiation processes [@Proserpio2016]. Within a population of cells, transcript detection differences can be regarded as a mixture of possible causes. 
On the broadest level, heterogeneity can be introduced by the presence of different cell types which leads to strong variations in gene expression that can be dissected using clustering approaches [@Rosenberg2018].
More subtle variation in gene expression is cause by deterministic or stochastic events, such as extrinsic or intrinsic transcriptional noise [@Elowitz2002].
Extrinsic noise is defined by differences in dynamic states (cell size, cell cycle, metabolism, intra- and inter-cellular signalling) while intrinsic noise effects single promoters via mutations, epigenetic modifications and nucleosome positioning [@Faure2017, @Eberwine2015].
Moreover, technical noise inflates the overall variability in gene expression [@Brennecke2013].
To account for high amounts of technical noise that affects scRNA-seq data, external RNA spike-in molecules (ERCCs) [@Rna2005] can be added to the experiment before sequencing. 
Fitting the variance-mean dependency of the ERCCs allows the statistical detection of genes with higher dispersion in expression than the technical background [@Brennecke2013]. 
This idea has been expanded to estimate cell specific normalisation factors in parallel within the BASiCS model. 
Total variability can be decomposed into a technical and biological part by incorporating ERCC reads [@Vallejos2015]. 

Since the era of bulk RNA sequencing, methods for differential expression testing of transcript counts across two conditions have been developed [@Anders2010;@Robinson2009]. 
Due to zero inflation in scRNA-seq data, new approaches were developed for differential expression testing in scRNA-seq data [@Katayama2013;@Kharchenko2014;@Delmans2016]. 
In contrast to bulk samples, scRNA-seq allows the characterization of gene expression variability across a population of cells. 
To compare changes in transcriptional variability, the BASiCS package has been expanded to include differential mean expression and differential variability testing. 
In this setting, BASiCS uses the over-dispersion after correcting for technical noise as proxy for biolgocial variability [@Vallejos2016a]. 
Due to a strong confounding between mean expression and over-dispersion, BASiCS has been extended to model this relationship and capture residual over-dispersion estimates that show no correlation to mean expression. 
Therefore, it is possible to test changes in mean expression in parallel to changes in variability [@Eling2018]. 

Here we present a computational workflow for differential expression and differential variability testing of scRNA-seq data using the previously published BASiCS package [@Vallejos2015;@Vallejos2016a;@Eling2017] implemented in the statistical computing language R. 
The analysis starts with a raw transcript counts matrix after removal of low-quality cells. 
A full quality control process is explained elsewhere [@McCarthy2017].
We will first focus on gene filtering, generating a SingleCellExpression object to use within BASiCS, and explain how to run and validate the convergence of Markov-Chain Monte Carlo simulations.
Additionally, we will use two examples (Cel-Seq [@Grun2014] and droplet-based scRNAseq data [@Ibarra-Soria2018]) to exemplify statistical detection of highly variable, differentially expressed and differentially variable genes in different conditions. 

# Methods

## The BASiCS model

The BASiCS package features a hierarchical Bayesian model in which the transcript count of gene $i$ of cell $j$ is represented as a random variable $X_{ij}$. 
For all technical genes, counts can be modelled as Poisson distributed with a random effect capturing unexplained technical noise:

$$
\begin{aligned}
X_{ij}|\mu_i,\nu_j&\sim{}\text{Poisson}(\nu_j\mu_i)\\
\nu_j|s_j,\theta&\sim{}\text{Gamma}(1/\theta,1/(s_j\theta))
\end{aligned}
$$

where $\mu_i$ explains the gene's mean expression, $\nu_j$ the technical effect dominated by the mRNA capture efficiency $s_j$ and the unexplained technical noise parameter $\theta$. 

This technical influence effects all biological genes in the same manner. 
In addition to technical variations, cell-to-cell differences of biological gene expression can be cause by biological processes as explained above. 
To model an additional random effect that captures biological cell-to-cell variability, the random variable $X_{ij}$ is modelled as: 

$$
\begin{aligned}
X_{ij}|\mu_i,\phi_j,\nu_j,\rho_{ij}&\sim{}\text{Poisson}(\phi_j\nu_j\mu_i\rho_{ij})\\
\rho_{ij}|\delta_i&\sim{}\text{Gamma}(1/\delta_i,1/\delta_i)
\end{aligned}
$$

where $\phi_j$ is the cell-specifc size factor and $\rho_{ij}$ the biological random effect incoroporating the over-dispersion hyper-parameter $\delta_i$.

In the further analysis, $\mu_i$ represents the mean expression and $\delta_i$ the biological over-dispersion of each gene.

### Testing for changes in mean expression and over-dispersion

Differential mean and differential over-dispersion testing is done by computing the tail posterior propabilities of the difference in mean expression or over-dispersion between two conditions ($A$ and $B$) being larger than an evidence threshold $\tau_0$ or $\omega_0$ [@Bochkina2007, @Vallejos2016]:

$$
\begin{aligned}
&\text{P}(\log(\mu_i^{(A)}/\mu_i^{(B)}))>\tau_0|\text{Data})>\alpha_m\\
&\text{P}(\log(\delta_i^{(A)}/\delta_i^{(B)}))>\omega_0|\text{Data})>\alpha_d
\end{aligned}
$$

If the tail posterior probability is larger than a given propability threshold $\alpha_m$ or $\alpha_d$, the gene is considered to be differentially expressed or differentially over-dispersed [@Vallejos2016]. 
The evidence threshold is usually fixed \emph{a priori} and the probability threshold is defined to control the expected false discovery rate (EFDR) to (e.g. 10%) [@Newton2004, Vallejos2016].

As described in Vallejos \emph{et al.}, 2016 [@Vallejos2016], estimates of the over-dispersion parameters $\delta_i$ are negatively correlated to mean expression $\mu_i$. 
This indicates that in homogeneous populations of cells, highly expressed genes tend to be less noisy than lowly expressed genes. 
Differential over-dispersion testing is therefor confounded by mean expression changes. 
When assessing changes in over-dispersion $\delta_i$, only genes with no changes in mean expression are considered (see Vallejos \emph{et al.}, 2016 [@Vallejos2016]).

### Correcting the mean-variability confounding effect

In Eling \emph{et al.}, 2018 [@Eling2018], we extended BASiCS to account for the confounding effect between mean expression and expression variability. 
For this purpose, we captured the relationship between mean and over-dispersion parameters by introducing the following joint prior distribution for $(\mu_i, \delta_i)'$: 

$$
\mu_i \sim \text{log-Normal}\left(0, s^2_{\mu}\right), \hspace{0.5cm}
\delta_i | \mu_i \sim \text{log-t}_{\eta}\left( \text{f}(\mu_i), \sigma^2 \right).
$$

The latter is equivalent to the non-linear regression model:

$$
\log(\delta_i) = \text{f}(\mu_i)+\epsilon_i, \hspace{0.5cm} \epsilon_i \sim{}\text{t}_{\eta}(0,\sigma^2), 
$$

where $\mbox{f}(\mu_i)$ represents the over-dispersion (on the log-scale) that is predicted by the global trend (across all genes) for a given mean expression $\mu_i$. 
Therefore, $\epsilon_i$ can be interpreted as a gene-specific \emph{residual over-dispersion} parameter. 
Positive values for $\epsilon_i$ indicate more variation than expected for genes with similar expression level. 
Similarly, negative values of $\epsilon_i$ suggest less variation than expected [@Eling2018].

In line with the probabilistic approach described above, we identified statistically significant differences in residual over-dispersion for those genes where the tail posterior probability of observing a large difference between $\epsilon_i^A$ and $\epsilon_i^B$ exceeds a certain threshold:

$$
\text{P}(\mid\epsilon_i^{A}-\epsilon_i^{B}\mid >\psi_0 \mid \text{Data} ) >\alpha_R,
$$
where $\psi_0 > 0$ defines the minimum tolerance threshold. 
As a default choice, we assume $\psi_0 = \log_2(1.5) / \log_2(e) \approx 0.41$ which translates into a 50% increase in over-dispersion. 
The posterior probability threshold $\alpha_R$ is chosen to control the EFDR (e.g. 10%) [@Newton2004]. 
To support interpretability of the results, we exclude genes that are not expressed in at least 2 cells per condition from differential variability testing.

### Parameter estimation when technical spike-in genes are not available

Explain the model when spike-ins are not available.

## Operation

This part of the methods should include the minimal system requirements needed to run the software and an overview of the workflow for the tool for users of the tool.

## Prerequisites 

*Move this section into the code once the workflow is done*

*And introduce each package that was used*

The following R packages and data objects are needed throughout the workflow.
We introduce them at this point as convinience and will link to this section whenever these objects are used.

```{r libraries}
library(BASiCS)
library(scater)
library(SingleCellExperiment)
library(scran)
library(coda)
library(goseq)
library(viridis)
library(pheatmap)
library(ggplot2)
```

To obtain gene annotations used in thiw workflow, we used the `biomaRt` package.
The **Mus musculus** gene ids and gene names can be directly accessed using the following code: 

```{r obtain-gene-symbols, message=FALSE}
library(biomaRt)
ensembl <- useMart("ensembl")
ensembl <- useDataset(dataset = "mmusculus_gene_ensembl", mart = ensembl)
genenames <- getBM(attributes = c("ensembl_gene_id", "external_gene_name"),
                   mart = ensembl)
rownames(genenames) <- genenames$ensembl_gene_id
```

To perform gene ontology (GO) analysis, we collect the length for each gene.
This can be extracted from the `EnsDb.Mmusculus.v79` package.

```{r, message=FALSE}
library(EnsDb.Mmusculus.v79)
exons.list <- exonsBy(EnsDb.Mmusculus.v79,by="gene")
genelength <- unlist(lapply(exons.list,function(x){sum(width(reduce(x)))}))
```

# Analysis of serum grown mESCs (single group example)

In the first case, we use scRNA-Seq data of mouse embryonic stem cells (mESCs) [@Grun2014] which were processed using the Cel-Seq protocol [@Hashimshony2012] while labelling individual transcripts using unique molecular identifiers (UMIs, [@Kivioja2011]). 
Cells grown in the 2i medium were sequenced to derive a method to accurately quantify technical and biological variability across the population on mESCs. 
Furthermore, Grün **et al.** sequenced serum grown mESCs to assess differences in expression variability between cells grown in 2i or serum conditions. 
This dataset contains ERCC spike-in genes [@Rna2005] which BASiCS uses to quantify technical noise.
In this section, we will use mESCs grown in serum conditions to dissect their heterogeneity in expression.

In the first insatnce, the data needs to be processed and filtered before running the BASiCS model.
For this, a counts matrix needs to be generated and the added spike-in counts need to be  calculated.

### Obtaining the data

The full dataset can be obtain from Gene Expression Omnibus (GEO) under the accessor: GSE54695.

```{r Grun-data}
library(R.utils)
library(data.table)
if(!file.exists("mESC_raw.txt")){
  download.file("ftp://ftp.ncbi.nlm.nih.gov/geo/series/GSE54nnn/GSE54695/suppl/GSE54695_data_transcript_counts.txt.gz", 
                destfile = "mESC_raw.txt.gz")
  gunzip("mESC_raw.txt.gz")
}
mESC.raw <- read.table("mESC_raw.txt", sep = "\t", header = TRUE)
```

## Preprocessing the data

This section generates the count matrix and collects metadata such as the batch information and growth condition.
The genenames are stored in the first column of the matrix. 

```{r Grun_preprocessing}
# Store genenames
rownames(mESC.raw) <- mESC.raw$GENENAME
mESC.raw <- mESC.raw[,-1]
```

The rows contain biological and technical genes while the columns contain cells or pooled RNA of different conditions.
All genes that were not expressed with at least a single transcript in at least two cells and two pooled RNA samples were discared before creating the final counts matrix.
Columns that contain individual cells are labeled with `SC` while columns that contain pooled RNA are labeled with `RNA`. 
The two conditions are labeled as `2i` and `serum`.

```{r data-overview}
# Biological and technical gene names
head(rownames(mESC.raw))
which(grepl("ERCC", rownames(mESC.raw)))

# Cell names
colnames(mESC.raw)
```

The counts matrix consists of transcript counts that were calculated based on binomial statistics from UMI counts (see [Sample GSM1322278](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSM1322278)).
To convert the transcript counts to raw UMI counts, the following function can be used.

```{r UMI-conversion}
# Generate raw UMI counts
UMICount <- function(MoleculeCount, UMILength)
{
  # MoleculeCount is the normalized count
  M = 4^UMILength
  UMICount = M*(1-exp(-MoleculeCount/M))
  return(UMICount)
}
CountsUMI = round(UMICount(mESC.raw, 4))
```

The data were processed in 2 batches per condition, each containing 40 cells or pooled RNA samples.
This information is stored in a batch vector.

```{r batches}
# Batch info
Batch <- rep(rep(c(1,2), each = 40), 4)
```

### Calculating the molecule count for spike-in genes

BASiCS requires the actual molecule count of the spike-in genes that were added per well.
For this, a table of the spike-in concentrations can be downloaded from: [ERCC spike-in](https://www.thermofisher.com/order/catalog/product/4456740).
The file contains the concentrations of 2 ERCC spike-in mixes.
The authors added 1\mu{}l of a 1:2,500,000 dilution of the ERCC mix 1 into each well.

```{r spike-in_download}
# Read in the spike-in concentrations
ERCC.conc <- read.table(url("https://assets.thermofisher.com/TFS-Assets/LSG/manuals/cms_095046.txt"), 
                         sep = "\t", header = TRUE)
```

The concentration is given in units of attomoles per \mu{}l. 
We will first calculate the concentration in moles per \mu{}l

```{r}
# Moles per micro litre
ERCC.mmul <- ERCC.conc$concentration.in.Mix.1..attomoles.ul.*(10^(-18))
```

From this, we can calculate the molecule count per \mu{}l.
1 mole is equals to 6.02214076*(10^23) molecules.

```{r}
ERCC.countmul <- ERCC.mmul*(6.02214076*(10^23))
```

The authors diluted this mix by 1:2,500,000.
The actual molecule number of spike-ins can therefore be calculated per well:

```{r}
ERCC.count <- ERCC.countmul/2500000
```

We can now use the molecule count to prepare the BASiCS data object.
To use this object within the `SingleCellExperiment` object that BASiCS requires, the first column must contain the names associated to the spike-in genes. 
The second column must contain the input number of molecules for the spike-in genes (amount per well).

```{r spike-info}
# Prepare the data.frame
ERCC.count <- data.frame(row.names = ERCC.conc$ERCC.ID,
                         Names = ERCC.conc$ERCC.ID,
                         count =ERCC.count)
```

## Creating the BASiCS Data object

In this section, we focus on the cells grown in serum condition to dissect their transcriptional heterogeneity.

```{r serum-cells}
# Select serum cells grown in serum media
serum.cells <- CountsUMI[,grepl("SC_serum", colnames(CountsUMI))]

# Select the serum batch vector
serum.batch <- Batch[grepl("SC_serum", colnames(CountsUMI))]
```

The BASiCS Data object is an object of the class `SingleCellExperiment` [@Lun2018SCE].
The `newBASiCS_Data` function can be used to create the required SingleCellExperiment object based on the following information:

* Counts: a matrix of raw expression counts with dimensions $q$ times $n$ where $q$ is the number of genes (technical + biological) and $n$ is the number of cells. Gene names must be stored as row names of the counts matrix.

* Tech: a vector of TRUE/FALSE elements with length $q$. If Tech[i] = FALSE the gene i is biological; otherwise the gene is spike-in. This vector must be specified in the same order of genes as in the counts matrix.

* SpikeInfo: a data.frame with $q-q_0$ rows where $q0$ is the number of biological genes. First column must contain the names associated to the spike-in genes. The second column must contain the input number of molecules for the spike-in genes (amount per cell).

* BatchInfo (optional argument): vector of length $n$ to indicate batch structure in situations where cells have been processed using multiple batches.

### Filtering the data

It is crucial to remove any unwanted variation in the data before running the BASiCS model. 
As in the original publication  (see [Sample GSM1322278](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSM1322278)), we removed samples with less than 10 transcripts of Oct4 (Pou5f1) to exclude differentiating cells or samples with low sequencing efficiency.
Furthermore, we remove genes that are not expressed with at least a single transcript in at least two cells.

```{r QC}
# Quality control - remove low Oct4 cells
Pou5f1.per.cell <- as.numeric(serum.cells["Pou5f1",])

serum.cells <- serum.cells[,Pou5f1.per.cell >= 10]
serum.batch <- serum.batch[Pou5f1.per.cell >= 10]

# Remove lowly expressed genes
no.cells <- apply(serum.cells, 1, function(n){sum(n >= 1)})
serum.cells <- serum.cells[no.cells >= 2,]
```

Using these filtered counts, we can now generate the BASiCS Data object.
For this, the `newBASiCS_Data` function can be used. 
If spike-in genes are not available, it is quicker to generate the `SingleCellExperiment`
object from scratch.

```{r serum-cells}
# Select the ERCC spike-ins of the dataset
SpikeInput <- ERCC.count[rownames(serum.cells)[grepl("ERCC", rownames(serum.cells))],]

Data.serum <- newBASiCS_Data(Counts = serum.cells, 
                       Tech = grepl("ERCC", rownames(serum.cells)), 
                       SpikeInfo = SpikeInput, 
                       BatchInfo = serum.batch)
Data.serum
```

### Running the MCMC

```{r MCMC}
MCMC.serum <- BASiCS_MCMC(Data = Data.serum, 
                          N=40000, Thin = 20, Burn = 20000, 
                          Regression = TRUE)
```

## Downstream analysis

### Normalization

### Variance decomposition

### Lowly-highly variable genes

### Comparison to DM (scran package)

# Differential testing using mESCs in two conditions (two group example)

## Obtaining the data

Shorter description as above

## Filtering the data

## Creating the BASiCS Data objects

## Running the MCMC

## Downstream analysis

### Differential mean expression

### Differential over-dispersion

### Differential residual over-dispersion

# Differential testing using differentiating cells (two group, droplet-based example)

With the development of droplet-based scRNA-Seq [@Klein2015, @Makosco2015] lead to a strong increase in the number of cells that can be profiled per experiment. 
With this, large-scale scRNA-Seq datasets have been generated to study development across multiple time-points and capturing musltiple tissues [@Ibarra-Soria2018, @Kernfeld2018]. 
Here we describe the computational analysis of changes in mean expression and transcriptional variability when data is sparse and technical spike-in genes are missing. 
For this, we compare cells of the presomitic mesoderm and somitic mesoderm using droplet-based scRNA-Seq data [@Ibarra-Soria2018].

## Obtaining the data

The full dataset is stored under the accession number E-MTAB-6153 on ArrayExpress and can be obtained via:

```{r load-droplet-data}
if(!file.exists("rawCounts.zip")){
  download.file("https://www.ebi.ac.uk/arrayexpress/files/E-MTAB-6153/E-MTAB-6153.processed.2.zip", 
                destfile = "rawCounts.zip")
  unzip(zipfile = "rawCounts.zip", exdir = "./")
}
rawCounts <- as.matrix(fread("rawCounts.tsv", sep = "\t", header = FALSE, 
                   data.table = FALSE))

# Genenames are stored in first column
rownames(rawCounts) <- rawCounts[,1]
rawCounts <- rawCounts[,-1]
```

*Of note:* The file is 65 mb in size while the unzipped, raw counts measure 873 mb in size.

The cluster labels of the original publication ca be obtained via:

```{r cluster-labels-droplet}
if(!file.exists("cluster_labels.zip")){
  download.file("https://www.ebi.ac.uk/arrayexpress/files/E-MTAB-6153/E-MTAB-6153.processed.3.zip", 
                destfile = "cluster_labels.zip")
  unzip(zipfile = "cluster_labels.zip", exdir = "./")
}

cluster_labels <- read.table("cellAnnotation.tsv", sep = "\t", header = TRUE, stringsAsFactors = FALSE)
```

## Generating SingleCellExperiment object

For pre-processing and visualization purposes, we load the data into a SingleCellExperiment object.
The metadata will be stored in the `colData` slot.

```{r droplet-sce}
droplet.sce <- SingleCellExperiment(assays=list(counts=as(rawCounts,"dgCMatrix")))
rm(rawCounts)
colData(droplet.sce) <- DataFrame(cluster_labels, subCellType = sub("_.*", "", cluster_labels$cell))
```

## Select populations of interest and quality control

We select the somitic and pre-somitic mesoderm cells to perform differential testing. 
Prior to running the MCMC, we want to control for outlying cells and heterogeneous substructure in both cell populations. 

```{r droplet-cell-selection}
droplet.sce <- droplet.sce[,which(colData(droplet.sce)$cellType == "presomiticMesoderm" | 
                             colData(droplet.sce)$cellType == "somiticMesoderm")]
```

For further processing steps, we remove lowly expressed genes.

```{r} 
droplet.sce <- droplet.sce[Matrix::rowMeans(counts(droplet.sce)) > 0.1,]
```

To visualize possible sub-structure in the data, we normalize both cell populations using the `scran` package.

```{r}
droplet.sce <- computeSumFactors(droplet.sce, 
                                 clusters=colData(droplet.sce)$subCellType)
droplet.sce <- normalize(droplet.sce)
```

Next, we compute a PCA using the `scater` package. 

```{r}
droplet.sce <- runPCA(droplet.sce)
```

We can now visualize the different factors stored in the `colData` slot.

```{r}
# Cell types identified by clustering
plotReducedDim(droplet.sce, use_dimred = "PCA", colour_by = "subCellType", alpha = 1) + 
  scale_fill_manual(values = c("coral4", "steelblue", "limegreen"))
```

The first PC separates the two different cell types while the second PC captures outlying cells.
We will remove these outliers and the intermediate cell population from down-stream analysis.

```{r}
droplet.sce <- droplet.sce[,reducedDims(droplet.sce)$PCA[,2] > -5 &
                             colData(droplet.sce)$subCellType != "presomiticMesoderm.b"]
```

We now collected the cells that we want to process using BASiCS. 
For this, we will generate the BASiCS data objects.

## Generating BASiCS data objects

Since droplet-based scRNA-Seq data are generated without including technical spike-in genes, BASiCS uses measurement error models to quantify technical variation through replication [@Carrol1998].
Here, it is crucial to provide batch information to the BASiCS model.
In the case of the somitic and pre-somoitic mesoderm cells, embryos of two mice have been used to generate the data. 
Cells isolated from the first embryo were split into two batches and processed independently.
To capture cell-type extrinsic, biological variation between the two mice, we pool cells from the two batches of the first animal and only considere cells from mouse 1 and mouse 2 as replicates.

```{r BASiCS-droplet-data}
# Presomitic mesoderm
cur_counts <- droplet.sce[,colData(droplet.sce)$cellType == "presomiticMesoderm"]
cur_batch <- round(colData(cur_counts)$sample, digits = 0)

PSM.Data <- newBASiCS_Data(Counts = as.matrix(counts(cur_counts)),
                           Tech = rep(FALSE, nrow(droplet.sce)),
                           SpikeInfo = NULL,
                           BatchInfo = cur_batch)

# Somitic mesoderm
cur_counts <- droplet.sce[,colData(droplet.sce)$cellType == "somiticMesoderm"]
cur_batch <- round(colData(cur_counts)$sample, digits = 0)

SM.Data <- newBASiCS_Data(Counts = as.matrix(counts(cur_counts)),
                           Tech = rep(FALSE, nrow(droplet.sce)),
                           SpikeInfo = NULL,
                           BatchInfo = cur_batch)
```

## Running the MCMC

We next estimate model parameters by running the MCMC cell-type specifically. 
Due to the high cell number (1150 for the pre-somitic mesoderm and 739 for the somitic mesoderm), we set the number of iterations to 20000. 
In this case, we used the regression BASiCS model to additionally estimate residual over-dispersion parameters.

```{r, eval = FALSE}
# Presomitic mesoderm cells
PSM.MCMC <- BASiCS_MCMC(PSM.Data, N = 20000, Thin = 10, Burn = 10000, Regression = TRUE)

# Somitic mesoderm cells
SM.MCMC <- BASiCS_MCMC(SM.Data, N = 20000, Thin = 10, Burn = 10000, Regression = TRUE)
```

Running these MCMC will take around 8-12 hours on a standard PC (2.6 GHz i5, 8 GB RAM, using 1 core). Here, we provide these chains to download from:

```{r droplet-chain-download}
PSM.MCMC <- readRDS("../../../Desktop/PSM_MCMC.rds")
SM.MCMC <- readRDS("../../../Desktop/SM_MCMC.rds")
```

## Validating the model fit

Next, we visualize the results of the MCMC sampler by visualizing the different chains and by plotting the regression trend.
To assess whether the chains converged, we will visualize trace plots for some of the parameters. 
The `mcmc` function of the `coda` package is suited to generate trace plots for each chain. 

```{r droplet-chain-convergence}
plot(mcmc(displayChainBASiCS(PSM.MCMC, Param = "mu")[,120]), main = "mu[120]")
plot(mcmc(displayChainBASiCS(PSM.MCMC, Param = "delta")[,10]), main = "delta[10]")
plot(mcmc(displayChainBASiCS(PSM.MCMC, Param = "epsilon")[,20]), main = "epsilon[20]")
plot(mcmc(displayChainBASiCS(PSM.MCMC, Param = "s")[,90]), main = "s[90]")
plot(mcmc(displayChainBASiCS(PSM.MCMC, Param = "nu")[,100]), main = "nu[100]")
plot(mcmc(displayChainBASiCS(PSM.MCMC, Param = "beta")[,2]), main = "beta[2]")
plot(mcmc(displayChainBASiCS(PSM.MCMC, Param = "sigma2")), main = "sigma2")

plot(mcmc(displayChainBASiCS(SM.MCMC, Param = "mu")[,120]), main = "mu[120]")
plot(mcmc(displayChainBASiCS(SM.MCMC, Param = "delta")[,10]), main = "delta[10]")
plot(mcmc(displayChainBASiCS(SM.MCMC, Param = "epsilon")[,20]), main = "epsilon[20]")
plot(mcmc(displayChainBASiCS(SM.MCMC, Param = "s")[,90]), main = "s[90]")
plot(mcmc(displayChainBASiCS(SM.MCMC, Param = "nu")[,100]), main = "nu[100]")
plot(mcmc(displayChainBASiCS(SM.MCMC, Param = "beta")[,2]), main = "beta[2]")
plot(mcmc(displayChainBASiCS(SM.MCMC, Param = "sigma2")), main = "sigma2")
```

We observe that the chains for all chosen paramteres converged. 
Furthermore, to validate that the model fitted the mean-variability trend correctly, we plot posterior estimates for over-dispersion paramters $\delta_i$ against posterior estimates of mean expression parameters $\mu_i$.
For this, the `BASiCS_showFit` function can be used.

```{r droplet-regression-trend}
BASiCS_showFit(PSM.MCMC)
BASiCS_showFit(SM.MCMC)
```

Both trends display similar behaviour which allows us to compare residual over-dispersion estimates.

## Differential testing 

Next, we test for changes in mean expression and expression variability between the somitic and pre-somitic mesoderm.
First, we are interested in assessing global changes in expression variability between the two conditions.
For this, over-dispersion paramters $\delta_i$ for genes that are similarly expressed in both conditions are compared.

```{r}
Droplet.Test.logFC0 <- BASiCS_TestDE(PSM.MCMC, SM.MCMC, EpsilonM = 0, 
                                     GroupLabel1 = "PSM", GroupLabel2 = "SM")
for.plot <- Droplet.Test.logFC0$TableDisp[Droplet.Test.logFC0$TableDisp$ResultDiffDisp != "ExcludedFromTesting",
                                          c("Disp1", "Disp2")]
for.plot <- melt(for.plot)
ggplot(for.plot) + geom_boxplot(aes(variable, log(value))) + 
  scale_x_discrete(labels = c("PSM", "SM")) + theme_minimal(base_size = 15) + 
  ylab("log(delta)") + xlab("")
```

### Global changes in variability

With this analysis, we do not detect global changes in expression variability.
We next profile changes in mean expression and expression variability on a gene-specific level.
For this, we use a log$_2$ fold change threshold of 1 for mean expression testing and the default threshold of $\psi_0\approx0.41$ for differential variability testing.

```{r droplet-gene-specific-testing}
Droplet.Test <- BASiCS_TestDE(PSM.MCMC, SM.MCMC, EpsilonM = 1, 
                                     GroupLabel1 = "PSM", GroupLabel2 = "SM", 
                              Plot = FALSE, PlotOffset = FALSE)

# Differential expression
ggplot(Droplet.Test$TableMean) + 
  geom_point(aes(log(MeanOverall), MeanLog2FC, colour = ResultDiffMean)) +
  theme_minimal(base_size = 15) + 
  scale_colour_manual(name = "Differential expression", values = c("grey80", "#2166ac", "#b2182b")) +
  ylab(expression(mu[PSM]/mu[SM])) + xlab(expression(log(mu))) 

# Differential variability
ggplot(Droplet.Test$TableResDisp) + 
  geom_point(aes(log(MeanOverall), ResDispDistance, colour = ResultDiffResDisp)) +
  theme_minimal(base_size = 15) + 
  scale_colour_manual(name = "Differential variability", values = c("black", "grey80", "#542788", "#b35806")) +
  ylab(expression(epsilon[PSM]-epsilon[SM])) + xlab(expression(log(mu))) 
```

### Differential mean expression

We can now list the genes that were detected as differenitally expressed and differentially variable ordered by their difference in mean expression/variability.
We first focus on genes that are differentially expressed between the two cell types.

```{r gene-lists-mean}
# Highly expressed in somitic mesoderm
SM.mean <- Droplet.Test$TableMean[Droplet.Test$TableMean$ResultDiffMean == "SM+",]
SM.mean <- SM.mean[order(SM.mean$MeanLog2FC, decreasing = FALSE),]
SM.mean$Symbol <- genenames[SM.mean$GeneName,2]

# Highly expressed in pre-somitic mesoderm
PSM.mean <- Droplet.Test$TableMean[Droplet.Test$TableMean$ResultDiffMean == "PSM+",]
PSM.mean <- PSM.mean[order(PSM.mean$MeanLog2FC, decreasing = TRUE),]
PSM.mean$Symbol <- genenames[PSM.mean$GeneName,2]
```

We can next perform GO analysis on up- or down-regulated genes. 
First, we will perform GO analysis on somitic mesoderm specific genes.

```{r GO-analysis-mean-SM}
# Collect significan genes as 1 and all other as 0
SM.genes <- as.integer(Droplet.Test$TableMean$ResultDiffMean == "SM+")
names(SM.genes) <- Droplet.Test$TableMean$GeneName

# Build a Null distribution by correcting the gene length bias
pwf = nullp(SM.genes, "mm10", "ensGene", bias.data = genelength[names(SM.genes)])
GO.wall = goseq(pwf,"mm10","ensGene")
SM.GO = DataFrame(GO.wall[p.adjust(GO.wall$over_represented_pvalue, method="fdr") < 0.01,])

# Add genenames to the GO categories
all_genes <- vector(length = nrow(SM.GO))
for(j in 1:nrow(SM.GO)){
  allegs = get(SM.GO$category[j], org.Mm.egGO2ALLEGS)
  genes = unique(unlist(mget(allegs, org.Mm.egENSEMBL)))
  genes = as.character(genes[genes %in% SM.mean$GeneName])
  all_genes[j] <- paste(genes, collapse = ", ")
}
SM.GO$Genes <- all_genes
```

Now, we perform GO analysis on pre-somitic mesoderm specific genes

```{r GO-analysis-mean-PSM}
# Collect significan genes as 1 and all other as 0
PSM.genes <- as.integer(Droplet.Test$TableMean$ResultDiffMean == "PSM+")
names(PSM.genes) <- Droplet.Test$TableMean$GeneName

# Build a Null distribution by correcting the gene length bias
pwf = nullp(PSM.genes, "mm10", "ensGene", bias.data = genelength[names(PSM.genes)])
GO.wall = goseq(pwf,"mm10","ensGene")
PSM.GO = DataFrame(GO.wall[p.adjust(GO.wall$over_represented_pvalue, method="fdr") < 0.01,])

# Add genenames to the GO categories
all_genes <- vector(length = nrow(PSM.GO))
for(j in 1:nrow(PSM.GO)){
  allegs = get(PSM.GO$category[j], org.Mm.egGO2ALLEGS)
  genes = unique(unlist(mget(allegs, org.Mm.egENSEMBL)))
  genes = as.character(genes[genes %in% PSM.mean$GeneName])
  all_genes[j] <- paste(genes, collapse = ", ")
}
PSM.GO$Genes <- all_genes
```

To visualize the expression of individual genes, we can use the `scater` package.

```{r violin-plots}
# Expression of Fgf8 in both conditions
plotExpression(droplet.sce, features = genenames[genenames$external_gene_name == "Fgf8",1], 
               x = "cellType", colour_by = "cellType")
plotReducedDim(droplet.sce, use_dimred = "PCA", 
               colour_by = genenames[genenames$external_gene_name == "Fgf8",1])
```

Visualize one category in form of heatmap.

```{r, fig.height=7, fig.width=5}
for.heatmap <- logcounts(droplet.sce)[unlist(strsplit(PSM.GO[1,"Genes"], ", ")),]
colnames(for.heatmap) <- colData(droplet.sce)$cell

# Order cells by cell type
for.heatmap <- for.heatmap[,order(colnames(for.heatmap))]

# Order rows by log2FC
for.heatmap <- for.heatmap[order(PSM.mean[match(rownames(for.heatmap), PSM.mean$GeneName),"MeanLog2FC"],
                                 decreasing = TRUE),]

pheatmap(for.heatmap, cluster_cols = FALSE, show_colnames = FALSE, cluster_rows = FALSE,
         color = colorRampPalette(c("#053061", "#4393c3", "white", "#d6604d", "#67001f"))(100), 
         labels_row = genenames[rownames(for.heatmap),2],
         cellheight = 8, fontsize = 7, annotation_col = data.frame(row.names = colnames(for.heatmap),
                  cellType = sub("_.*", "", colnames(for.heatmap))), scale = "row")
```


### Differential variability testing

Next, we are interested in genes that change in variability between the two cell types.
To help interpretion of the result, we will split the genes into four categories.
These include:
* More variable in SM, highly expressed in SM
* More variable in SM, lowly expressed in SM
* More variable in PSM, highly expressed in PSM
* More variable in PSM, lowly expressed in SM

```{r}
gene.groups <- data.frame(Genename = Droplet.Test$TableResDisp$GeneName,
                          Symbol = genenames[Droplet.Test$TableResDisp$GeneName,2],
                          MeanLog2FC = Droplet.Test$TableMean$MeanLog2FC,
                          ResDispDistance = Droplet.Test$TableResDisp$ResDispDistance,
                          Regulation = paste(Droplet.Test$TableMean$ResultDiffMean, 
                                             Droplet.Test$TableResDisp$ResultDiffResDisp,
                                             sep = "_"))
gene.groups <- gene.groups[gene.groups$Regulation %in% 
                             c("SM+_SM+", "SM+_PSM+", "PSM+_PSM+","PSM+_SM+"),]

gene.groups[gene.groups$Regulation == "SM+_SM+",]
```

We can visualize individual genes using `scater`.

```{r violin-plots}
# Expression of Meox2 in both conditions
plotExpression(droplet.sce, features = genenames[genenames$external_gene_name == "Meox2",1], 
               x = "cellType", colour_by = "cellType") + 
  scale_fill_manual(values = c("coral4", "limegreen"))
plotReducedDim(droplet.sce, use_dimred = "PCA", 
               colour_by = genenames[genenames$external_gene_name == "Meox2",1], alpha = 1)
```

# Summary 
This section is required if the paper does not include novel data or analyses.  It allows authors to briefly summarize the key points from the article.


# Software availability
This section will be generated by the Editorial Office before publication. Authors are asked to provide some initial information to assist the Editorial Office, as detailed below.

1. URL link to where the software can be downloaded from or used by a non-coder (AUTHOR TO PROVIDE; optional)
2. URL link to the author's version control system repository containing the source code (AUTHOR TO PROVIDE; required)
3. Link to source code as at time of publication (*F1000Research* TO GENERATE)
4. Link to archived source code as at time of publication (*F1000Research* TO GENERATE)
5. Software license (AUTHOR TO PROVIDE; required)


# Author information
In order to give appropriate credit to each author of an article, the individual contributions of each author to the manuscript should be detailed in this section. We recommend using author initials and then stating briefly how they contributed.

# Competing interests
All financial, personal, or professional competing interests for any of the authors that could be construed to unduly influence the content of the article must be disclosed and will be displayed alongside the article. If there are no relevant competing interests to declare, please add the following: 'No competing interests were disclosed'.

# Grant information
Please state who funded the work discussed in this article, whether it is your employer, a grant funder etc. Please do not list funding that you have that is not relevant to this specific piece of research. For each funder, please state the funder’s name, the grant number where applicable, and the individual to whom the grant was assigned. If your work was not funded by any grants, please include the line: 'The author(s) declared that no grants were involved in supporting this work.'

# Acknowledgments
This section should acknowledge anyone who contributed to the research or the article but who does not qualify as an author based on the criteria provided earlier (e.g. someone or an organization that provided writing assistance). Please state how they contributed; authors should obtain permission to acknowledge from all those mentioned in the Acknowledgments section.

Please do not list grant funding in this section.