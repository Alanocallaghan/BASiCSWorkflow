---
title: "A BASiCS workflow for expression variability analysis using scRNA-Seq data"
author:
- name: Nils Eling
  affiliation: 
  - &EBI European Molecular Biology Laboratory, European Bioinformatics 
  Institute, Wellcome Trust Genome Campus, Hinxton, Cambridge CB10 1SD, UK
  - &CRUK Cancer Research UK Cambridge Institute, University of Cambridge, 
  Li Ka Shing Centre, Cambridge, CB2 0RE, UK
- name: John C. Marioni
  affiliation: 
  - *EBI
  - *CRUK
- name: Catalina A. Vallejos
  affiliation: 
  - MRC Human Genetics Unit, Institute of Genetics & Molecular Medicine, 
  University of Edinburgh, Western General Hospital, Crewe Road, Edinburgh
  EH4 2XU, UK
  - The Alan Turing Institute, British Library, 96 Euston Road, London 
  NW1 2DB, UK
  email: catalina.vallejos@igmm.ed.ac.uk
abstract: Cell-to-cell heterogeneity in gene expression is an inherent feature 
of biological systems. Single-cell RNA sequencing can be used to quantify this 
heterogeneity, but it is prone to strong technical noise. Here, we describe a 
computational workflow that uses the BASiCS Bioconductor package to robustly 
quantify cell-to-cell expression variability within and between known cell 
populations (e.g.~experimental conditions or cell types). We illustrate how 
BASiCS can identify highly and lowly variable genes within a cell population. 
We also show how BASiCS can highlight changes in gene expression variability 
between cell populations, while avoiding confounding effects related to 
technical noise or changes in overall abundance. Using publicly available 
datasets, we guide users through a complete pipeline which includes preliminary 
steps for quality control and data exploration using the scater Bioconductor 
package. Two case studies are described. The first uses data generated using the 
Fluidigm\@ C1 system, in which spike-in RNA molecules are used in order to 
quantify technical noise. The second dataset was generated using a droplet-based 
system, for which spike-in RNA is not available. The latter analysis provides an 
example in which differential variability testing reveals insights regarding a 
possible early cell fate commitment process. 

#Abstracts should be up to 300 words and provide a succinct summary of the article. Although the abstract should explain why the article might be interesting, care should be taken not to inappropriately over-emphasise the importance of the work described in the article. Citations should not be used in the abstract, and the use of abbreviations should be minimized.
keywords: Single-cell RNA sequencing, expression variability, noise, 
differential expression testing
bibliography: BASiCSworkflow.bib
output: BiocWorkflowTools::f1000_article
#output:
# BiocStyle::html_document:
#   fig_caption: true
#   self_contained: yes
#vignette: >
#  %\VignetteIndexEntry{A BASiCS workflow for expression variability analysis using scRNAseq data}
#  %\VignetteEngine{knitr::rmarkdown}
#  %\VignetteEncoding{UTF-8}
---

```{r setup_knitr, include = FALSE, cache = FALSE}
#library(BiocStyle)
## Decide whether to display parts for BioC (TRUE) or F1000 (FALSE)
#on.bioc <- TRUE
#library(knitr)
# Use fig.width = 7 for html and fig.width = 6 for pdf
#fig.width <- ifelse(on.bioc, 7, 6)
#knitr::opts_chunk$set(cache = 2, warning = FALSE, message = FALSE, error = FALSE,
#  cache.path = "cache/", fig.path = "figure/", fig.width = fig.width)
```

# Introduction

<!--- This paragraph: scRNA-Seq and the different types of heterogeneity --->
<!--- Ref to clustering removed, as the focus is on the types of heterogeneity,
not in the analysis. Check if @Rosenberg2018 reference is still relevant --> 
Single-cell RNA-sequencing (scRNA-Seq) is the leading technology to study 
genome-wide transcriptional heterogeneity in cell populations that remains 
otherwise undetected in bulk experiments [@Stegle2015]. Its applications range 
from uncovering novel cell types in immunity [@Lonnberg2017, @Villani2017] 
and development [@Ibarra-Soria2018a, @Wagner2018] to dissecting the mechanism 
for cell-to-cell differences in expression [@Goolam2016] or understanding 
differentiation processes [@Proserpio2016]. Within a population of cells, 
transcriptional heterogeneity can be due a mixture of possible causes. On the 
broadest level, this heterogeneity can reflect the presence of cell subtypes 
with distinct expression profiles [@Rosenberg2018]. More subtle variation within 
a seemingly homogeneous cell population can be due to deterministic or 
stochastic events, such as extrinsic or intrinsic transcriptional noise 
[@Elowitz2002]. 
<!--- edited until here ---> 
Extrinsic noise is defined by differences in dynamic states (cell size, cell cycle, metabolism, intra- and inter-cellular signalling) while intrinsic noise effects single promoters via mutations, epigenetic modifications and nucleosome positioning [@Faure2017, @Eberwine2015].

<!--- This paragraph: technical noise, normalisation and hvg/lvg analyses ---> 
Moreover, technical noise inflates the overall variability in gene expression [@Brennecke2013].
To account for high amounts of technical noise that affects scRNA-seq data, external RNA spike-in molecules (ERCCs) [@Rna2005] can be added to the experiment before sequencing. 
Fitting the variance-mean dependency of the ERCCs allows the statistical detection of genes with higher dispersion in expression than the technical background [@Brennecke2013]. 
This idea has been expanded to estimate cell specific normalisation factors in parallel within the BASiCS model. 
Total variability can be decomposed into a technical and biological part by incorporating ERCC reads [@Vallejos2015]. 

<!--- This paragraph: differential analyses ---> 
Since the era of bulk RNA sequencing, methods for differential expression testing of transcript counts across two conditions have been developed [@Anders2010;@Robinson2009]. 
Due to zero inflation in scRNA-seq data, new approaches were developed for differential expression testing in scRNA-seq data [@Katayama2013;@Kharchenko2014;@Delmans2016]. 
In contrast to bulk samples, scRNA-seq allows the characterization of gene expression variability across a population of cells. 
To compare changes in transcriptional variability, the BASiCS package has been expanded to include differential mean expression and differential variability testing. 
In this setting, BASiCS uses the over-dispersion after correcting for technical noise as proxy for biolgocial variability [@Vallejos2016a]. 
Due to a strong confounding between mean expression and over-dispersion, BASiCS has been extended to model this relationship and capture residual over-dispersion estimates that show no correlation to mean expression. 
Therefore, it is possible to test changes in mean expression in parallel to changes in variability [@Eling2018]. 

<!--- This paragraph: outline ---> 
Here we present a computational workflow for differential expression and differential variability testing of scRNA-seq data using the previously published BASiCS package [@Vallejos2015;@Vallejos2016a;@Eling2017] implemented in the statistical computing language R. 
The analysis starts with a raw transcript counts matrix after removal of low-quality cells. 
A full quality control process is explained elsewhere [@McCarthy2017].
We will first focus on gene filtering, generating a SingleCellExpression object to use within BASiCS, and explain how to run and validate the convergence of Markov-Chain Monte Carlo simulations.
Additionally, we will use two examples (Cel-Seq [@Grun2014] and droplet-based scRNAseq data [@Ibarra-Soria2018]) to exemplify statistical detection of highly variable, differentially expressed and differentially variable genes in different conditions. 

# Methods

- Explain BASiCS from a users perspective (4 different cases)
- Coda package for MCMC visualization, MCMC convergency analysis, effective sample size
- Explain scater for preprocessing (highlight: QC, pre-normalization and visualization)
- scran for alternative measures e.g. DM and CV2 calculation
- GO analysis

## Outline

**Mike Love, Charlotte Sonesone, Rob Patron**
**We explain the workflow outline.**
**This has to be very easy to understand.**

## Operation

**Here we mention the version of R and Bioconductor that we are using.** 
*Specifically name the Bioconductor packages that we are using**

## Prerequisites 

*Move this section into the code once the workflow is done*

*And introduce each package that was used*

The following R packages and data objects are needed throughout the workflow.
We introduce them at this point as convinience and will link to this section whenever these objects are used.

```{r libraries}
library(BASiCS)
library(scater)
library(SingleCellExperiment)
library(scran)
library(coda)
library(goseq)
library(viridis)
library(pheatmap)
library(ggplot2)
```

To obtain gene annotations used in thiw workflow, we used the `biomaRt` package.
The **Mus musculus** gene ids and gene names can be directly accessed using the following code: 

```{r obtain-gene-symbols, message=FALSE}
library(biomaRt)
ensembl <- useMart("ensembl")
ensembl <- useDataset(dataset = "mmusculus_gene_ensembl", mart = ensembl)
genenames <- getBM(attributes = c("ensembl_gene_id", "external_gene_name"),
                   mart = ensembl)
rownames(genenames) <- genenames$ensembl_gene_id
```

To perform gene ontology (GO) analysis, we collect the length for each gene.
This can be extracted from the `EnsDb.Mmusculus.v79` package.

```{r, message=FALSE}
library(EnsDb.Mmusculus.v79)
exons.list <- exonsBy(EnsDb.Mmusculus.v79,by="gene")
genelength <- unlist(lapply(exons.list,function(x){sum(width(reduce(x)))}))
```

# Analysis of naive CD4+ T cells (single group example)

In the first case, we use scRNA-Seq data of naive CD4+ T cells [@Martinez-jimenez2017] which were processed using the C1 Single-Cell Auto Prep System (FluidigmÂ®). 
Cells were grown in three different media (serum + leukemia inhibitory factor (LIF), 2i + LIF and a2i + LIF).
For simplicity, we refer to the different growth media as: serum, 2i and a2i.
The 2i and a2i media were developed to maintain a so called "ground state pluripotency" in mESCs in contrast to the serum condition [@Wray2011, @Li2011], in which cells display heterogeneity within their pluripotent/differentiation state [@Kolodziejczyk2015].
The authors designed the study to dissect transcriptional heterogeneity within mESCs cultered in these three condition.
Furthermore, cells from each condition were captured and processed in multiple replicates (also referred to as batches).
The batch structure of the full dataset is as follows: 3 batches for serum grown cells, 4 batches for 2i grown cells and two replicates for a2i grown cells.
This dataset contains ERCC spike-in genes [@Rna2005] which BASiCS uses to quantify technical noise.

In the first instance, the data needs to be obtained, processed and filtered before running the BASiCS model.

## Creating the input data

### Obtaining the data

The raw counts of the full dataset can be obtain from ArrayExpress under the accession number [E-MTAB-4888](https://www.ebi.ac.uk/arrayexpress/experiments/E-MTAB-4888/).
The column names contain the library identifier of the original experiment while the row names of the matrix store the individual gene names. 
The dataset contains reads mapping to ERCC spike-in genes [@Rna2005], which `BASiCS` uses to estimate and remove technical noise.

```{r mESC-data}
if(!file.exists("raw_data.txt")){
  # Download raw counts file
  download.file("https://www.ebi.ac.uk/arrayexpress/files/E-MTAB-4888/E-MTAB-4888.processed.1.zip", 
                destfile = "raw_data.txt.zip")
  # Unzip file
  unzip("raw_data.txt.zip")
}
CD4.raw <- read.table("raw_data.txt", header = TRUE, sep = "\t")

# Show row and column names
head(colnames(CD4.raw))
head(rownames(CD4.raw))

# ERCC spike-in genes
rownames(CD4.raw)[grepl("ERCC", rownames(CD4.raw))]
```

In this section, we highlight the single-condition analysis that can be performed using `BASiCS`.
For this, we will use mESCs grown in serum conditions to dissect their heterogeneity in expression.
For further use, we store the batch information of the cells in a separate vector.

```{r selecting-serum-cells}
# Select serum conditions - also referred to as 'lif' in the column names
mESC.serum <- mESC.raw[,grepl("lif", colnames(mESC.raw))]
dim(mESC.serum)

# Storing the batch information
batch.serum <- sapply(colnames(mESC.serum), function(n){unlist(strsplit(n, "_"))[4]})
```

We now obtained 250 mESCs cultured in serum, which were processed across 3 batches. 

### Calculating the molecule count for spike-in genes

BASiCS requires the actual molecule count of the spike-in genes that were added per well.
For this, a table of the spike-in concentrations can be downloaded from: [ERCC spike-in](https://www.thermofisher.com/order/catalog/product/4456740).
The file contains the concentrations of 2 ERCC spike-in mixes.

**Add the dilution factor for Olas data**

The authors added 1\mu{}l of a 1: dilution of the ERCC mix 1 into each well.

```{r spike-in_download}
# Read in the spike-in concentrations
ERCC.conc <- read.table(url("https://assets.thermofisher.com/TFS-Assets/LSG/manuals/cms_095046.txt"), 
                         sep = "\t", header = TRUE)
```

The concentration is given in units of attomoles per \mu{}l. 
We will first calculate the concentration in moles per \mu{}l

```{r}
# Moles per micro litre
ERCC.mmul <- ERCC.conc$concentration.in.Mix.1..attomoles.ul.*(10^(-18))
```

From this, we can calculate the molecule count per \mu{}l.
1 mole is equals to 6.02214076*(10^23) molecules.

```{r}
ERCC.countmul <- ERCC.mmul*(6.02214076*(10^23))
```

The authors diluted this mix by **1:2,500,000**.
The actual molecule number of spike-ins can therefore be calculated per well:

```{r}
ERCC.count <- ERCC.countmul/2500000
```

We can now use the molecule count to prepare the BASiCS data object.
To incorporate the ERCC molecule counts within the `SingleCellExperiment` object that BASiCS requires, the first column must contain the names associated to the spike-in genes. 
The second column must contain the input number of molecules for the spike-in genes (amount per well).

```{r spike-info}
# Prepare the data.frame
ERCC.count <- data.frame(row.names = ERCC.conc$ERCC.ID,
                         Names = ERCC.conc$ERCC.ID,
                         count = ERCC.count)
```

## Creating the SingleCellExperiment object

The BASiCS Data object is an object of the class `SingleCellExperiment` [@Lun2018SCE].
The `newBASiCS_Data` function can be used to create the required SingleCellExperiment object based on the following information:

* Counts: a matrix of raw expression counts with dimensions $q$ times $n$ where $q$ is the number of genes (technical + biological) and $n$ is the number of cells. Gene names must be stored as row names of the counts matrix.

* Tech: a vector of TRUE/FALSE elements with length $q$. If Tech[i] = FALSE the gene i is biological; otherwise the gene is spike-in. This vector must be specified in the same order of genes as in the counts matrix.

* SpikeInfo: a data.frame with $q-q_0$ rows where $q_0$ is the number of biological genes. First column must contain the names associated to the spike-in genes. The second column must contain the input number of molecules for the spike-in genes (amount per cell).

* BatchInfo (optional argument): vector of length $n$ to indicate batch structure in situations where cells have been processed using multiple batches.

```{r serum-cells}
# Select the ERCC spike-ins of the dataset
SpikeInput <- ERCC.count[rownames(mESC.serum)[grepl("ERCC", rownames(mESC.serum))],]

Data.serum <- newBASiCS_Data(Counts = mESC.serum, 
                       Tech = grepl("ERCC", rownames(mESC.serum)), 
                       SpikeInfo = SpikeInput, 
                       BatchInfo = batch.serum)
Data.serum
```

### Filtering the data

It is crucial to perform thorough quality-control before running the BASiCS model. 
This includes removing low-quality cells as well as non-informative genes such as the ones with low expression. 
The authors removed empty capture sites and sites which contained multiple cells or debris as observed by visual inspection. 
Furthermore, they removed cells which had fewer than 500,000 reads that mapped to exons or cells that had more than 10% of mitochondrial reads [@Kolodziejczyk2015].
The `scater` package has been created to visualize and calcualte quality measures from scRNA-Seq experiments.
Here, we visualize further quality measures using `scater`.

**Use scater for data visaulization and QC**

It is crucial to remove any unwanted variation in the data before running the BASiCS model. 
As in the original publication  (see [Sample GSM1322278](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSM1322278)), we removed samples with less than 10 transcripts of Oct4 (Pou5f1) to exclude differentiating cells or samples with low sequencing efficiency.
Furthermore, we remove genes that are not expressed with at least a single transcript in at least two cells.

```{r QC}
# Quality control - remove low Oct4 cells
Pou5f1.per.cell <- as.numeric(serum.cells["Pou5f1",])

serum.cells <- serum.cells[,Pou5f1.per.cell >= 10]
serum.batch <- serum.batch[Pou5f1.per.cell >= 10]

# Remove lowly expressed genes
no.cells <- apply(serum.cells, 1, function(n){sum(n >= 1)})
serum.cells <- serum.cells[no.cells >= 2,]
```

Using these filtered counts, we can now generate the BASiCS Data object.
For this, the `newBASiCS_Data` function can be used. 
If spike-in genes are not available, it is quicker to generate the `SingleCellExperiment`
object from scratch.

```{r serum-cells}
# Select the ERCC spike-ins of the dataset
SpikeInput <- ERCC.count[rownames(serum.cells)[grepl("ERCC", rownames(serum.cells))],]

Data.serum <- newBASiCS_Data(Counts = serum.cells, 
                       Tech = grepl("ERCC", rownames(serum.cells)), 
                       SpikeInfo = SpikeInput, 
                       BatchInfo = serum.batch)
Data.serum
```

### Running the MCMC

```{r MCMC}
MCMC.serum <- BASiCS_MCMC(Data = Data.serum, 
                          N=40000, Thin = 20, Burn = 20000, 
                          Regression = TRUE)
```

### Validating the MCMC convergence

## Downstream analysis

### Normalization

### Variance decomposition

### Lowly-highly variable genes

### Mean-variance trend

### Comparison to DM (scran package)

**Compare delta to CV2 and epsilon to DM**

# Differential testing using mESCs in two conditions (two group example)

## Obtaining the data

Shorter description as above

## Filtering the data

## Creating the BASiCS Data objects

## Running the MCMC

## Downstream analysis

### Differential mean expression

### Differential over-dispersion

### Differential residual over-dispersion

# Differential testing using differentiating cells (two group, droplet-based example)

With the development of droplet-based scRNA-Seq [@Klein2015, @Makosco2015] lead to a strong increase in the number of cells that can be profiled per experiment. 
With this, large-scale scRNA-Seq datasets have been generated to study development across multiple time-points and capturing musltiple tissues [@Ibarra-Soria2018, @Kernfeld2018]. 
Here we describe the computational analysis of changes in mean expression and transcriptional variability when data is sparse and technical spike-in genes are missing. 
For this, we compare cells of the presomitic mesoderm and somitic mesoderm using droplet-based scRNA-Seq data [@Ibarra-Soria2018].

## Obtaining the data

The full dataset is stored under the accession number E-MTAB-6153 on ArrayExpress and can be obtained via:

```{r load-droplet-data}
if(!file.exists("rawCounts.zip")){
  download.file("https://www.ebi.ac.uk/arrayexpress/files/E-MTAB-6153/E-MTAB-6153.processed.2.zip", 
                destfile = "rawCounts.zip")
  unzip(zipfile = "rawCounts.zip", exdir = "./")
}
rawCounts <- as.matrix(fread("rawCounts.tsv", sep = "\t", header = FALSE, 
                   data.table = FALSE))

# Genenames are stored in first column
rownames(rawCounts) <- rawCounts[,1]
rawCounts <- rawCounts[,-1]
```

*Of note:* The file is 65 mb in size while the unzipped, raw counts measure 873 mb in size.

The cluster labels of the original publication ca be obtained via:

```{r cluster-labels-droplet}
if(!file.exists("cluster_labels.zip")){
  download.file("https://www.ebi.ac.uk/arrayexpress/files/E-MTAB-6153/E-MTAB-6153.processed.3.zip", 
                destfile = "cluster_labels.zip")
  unzip(zipfile = "cluster_labels.zip", exdir = "./")
}

cluster_labels <- read.table("cellAnnotation.tsv", sep = "\t", header = TRUE, stringsAsFactors = FALSE)
```

## Generating SingleCellExperiment object

For pre-processing and visualization purposes, we load the data into a SingleCellExperiment object.
The metadata will be stored in the `colData` slot.

```{r droplet-sce}
droplet.sce <- SingleCellExperiment(assays=list(counts=as(rawCounts,"dgCMatrix")))
rm(rawCounts)
colData(droplet.sce) <- DataFrame(cluster_labels, subCellType = sub("_.*", "", cluster_labels$cell))
```

## Select populations of interest and quality control

We select the somitic and pre-somitic mesoderm cells to perform differential testing. 
Prior to running the MCMC, we want to control for outlying cells and heterogeneous substructure in both cell populations. 

```{r droplet-cell-selection}
droplet.sce <- droplet.sce[,which(colData(droplet.sce)$cellType == "presomiticMesoderm" | 
                             colData(droplet.sce)$cellType == "somiticMesoderm")]
```

For further processing steps, we remove lowly expressed genes.

```{r} 
droplet.sce <- droplet.sce[Matrix::rowMeans(counts(droplet.sce)) > 0.1,]
```

To visualize possible sub-structure in the data, we normalize both cell populations using the `scran` package.

```{r}
droplet.sce <- computeSumFactors(droplet.sce, 
                                 clusters=colData(droplet.sce)$subCellType)
droplet.sce <- normalize(droplet.sce)
```

Next, we compute a PCA using the `scater` package. 

```{r}
droplet.sce <- runPCA(droplet.sce)
```

We can now visualize the different factors stored in the `colData` slot.

```{r}
# Cell types identified by clustering
plotReducedDim(droplet.sce, use_dimred = "PCA", colour_by = "subCellType", alpha = 1) + 
  scale_fill_manual(values = c("coral4", "steelblue", "limegreen"))
```

The first PC separates the two different cell types while the second PC captures outlying cells.
We will remove these outliers and the intermediate cell population from down-stream analysis.

```{r}
droplet.sce <- droplet.sce[,reducedDims(droplet.sce)$PCA[,2] > -5 &
                             colData(droplet.sce)$subCellType != "presomiticMesoderm.b"]
```

We now collected the cells that we want to process using BASiCS. 
For this, we will generate the BASiCS data objects.

## Generating BASiCS data objects

Since droplet-based scRNA-Seq data are generated without including technical spike-in genes, BASiCS uses measurement error models to quantify technical variation through replication [@Carrol1998].
Here, it is crucial to provide batch information to the BASiCS model.
In the case of the somitic and pre-somoitic mesoderm cells, embryos of two mice have been used to generate the data. 
Cells isolated from the first embryo were split into two batches and processed independently.
To capture cell-type extrinsic, biological variation between the two mice, we pool cells from the two batches of the first animal and only considere cells from mouse 1 and mouse 2 as replicates.

```{r BASiCS-droplet-data}
# Presomitic mesoderm
cur_counts <- droplet.sce[,colData(droplet.sce)$cellType == "presomiticMesoderm"]
cur_batch <- round(colData(cur_counts)$sample, digits = 0)

PSM.Data <- newBASiCS_Data(Counts = as.matrix(counts(cur_counts)),
                           Tech = rep(FALSE, nrow(droplet.sce)),
                           SpikeInfo = NULL,
                           BatchInfo = cur_batch)

# Somitic mesoderm
cur_counts <- droplet.sce[,colData(droplet.sce)$cellType == "somiticMesoderm"]
cur_batch <- round(colData(cur_counts)$sample, digits = 0)

SM.Data <- newBASiCS_Data(Counts = as.matrix(counts(cur_counts)),
                           Tech = rep(FALSE, nrow(droplet.sce)),
                           SpikeInfo = NULL,
                           BatchInfo = cur_batch)
```

## Running the MCMC

We next estimate model parameters by running the MCMC cell-type specifically. 
Due to the high cell number (1150 for the pre-somitic mesoderm and 739 for the somitic mesoderm), we set the number of iterations to 20000. 
In this case, we used the regression BASiCS model to additionally estimate residual over-dispersion parameters.

```{r, eval = FALSE}
# Presomitic mesoderm cells
PSM.MCMC <- BASiCS_MCMC(PSM.Data, N = 20000, Thin = 10, Burn = 10000, Regression = TRUE)

# Somitic mesoderm cells
SM.MCMC <- BASiCS_MCMC(SM.Data, N = 20000, Thin = 10, Burn = 10000, Regression = TRUE)
```

Running these MCMC will take around 8-12 hours on a standard PC (2.6 GHz i5, 8 GB RAM, using 1 core). Here, we provide these chains to download from:

```{r droplet-chain-download}
PSM.MCMC <- readRDS("../../../Desktop/PSM_MCMC.rds")
SM.MCMC <- readRDS("../../../Desktop/SM_MCMC.rds")
```

## Validating the model fit

Next, we visualize the results of the MCMC sampler by visualizing the different chains and by plotting the regression trend.
To assess whether the chains converged, we will visualize trace plots for some of the parameters. 
The `mcmc` function of the `coda` package is suited to generate trace plots for each chain. 

```{r droplet-chain-convergence}
plot(mcmc(displayChainBASiCS(PSM.MCMC, Param = "mu")[,120]), main = "mu[120]")
plot(mcmc(displayChainBASiCS(PSM.MCMC, Param = "delta")[,10]), main = "delta[10]")
plot(mcmc(displayChainBASiCS(PSM.MCMC, Param = "epsilon")[,20]), main = "epsilon[20]")
plot(mcmc(displayChainBASiCS(PSM.MCMC, Param = "s")[,90]), main = "s[90]")
plot(mcmc(displayChainBASiCS(PSM.MCMC, Param = "nu")[,100]), main = "nu[100]")
plot(mcmc(displayChainBASiCS(PSM.MCMC, Param = "beta")[,2]), main = "beta[2]")
plot(mcmc(displayChainBASiCS(PSM.MCMC, Param = "sigma2")), main = "sigma2")

plot(mcmc(displayChainBASiCS(SM.MCMC, Param = "mu")[,120]), main = "mu[120]")
plot(mcmc(displayChainBASiCS(SM.MCMC, Param = "delta")[,10]), main = "delta[10]")
plot(mcmc(displayChainBASiCS(SM.MCMC, Param = "epsilon")[,20]), main = "epsilon[20]")
plot(mcmc(displayChainBASiCS(SM.MCMC, Param = "s")[,90]), main = "s[90]")
plot(mcmc(displayChainBASiCS(SM.MCMC, Param = "nu")[,100]), main = "nu[100]")
plot(mcmc(displayChainBASiCS(SM.MCMC, Param = "beta")[,2]), main = "beta[2]")
plot(mcmc(displayChainBASiCS(SM.MCMC, Param = "sigma2")), main = "sigma2")
```

We observe that the chains for all chosen paramteres converged. 
Furthermore, to validate that the model fitted the mean-variability trend correctly, we plot posterior estimates for over-dispersion paramters $\delta_i$ against posterior estimates of mean expression parameters $\mu_i$.
For this, the `BASiCS_showFit` function can be used.

```{r droplet-regression-trend}
BASiCS_showFit(PSM.MCMC)
BASiCS_showFit(SM.MCMC)
```

Both trends display similar behaviour which allows us to compare residual over-dispersion estimates.

## Differential testing 

Next, we test for changes in mean expression and expression variability between the somitic and pre-somitic mesoderm.
First, we are interested in assessing global changes in expression variability between the two conditions.
For this, over-dispersion paramters $\delta_i$ for genes that are similarly expressed in both conditions are compared.

```{r}
Droplet.Test.logFC0 <- BASiCS_TestDE(PSM.MCMC, SM.MCMC, EpsilonM = 0, 
                                     GroupLabel1 = "PSM", GroupLabel2 = "SM")
for.plot <- Droplet.Test.logFC0$TableDisp[Droplet.Test.logFC0$TableDisp$ResultDiffDisp != "ExcludedFromTesting",
                                          c("Disp1", "Disp2")]
for.plot <- melt(for.plot)
ggplot(for.plot) + geom_boxplot(aes(variable, log(value))) + 
  scale_x_discrete(labels = c("PSM", "SM")) + theme_minimal(base_size = 15) + 
  ylab("log(delta)") + xlab("")
```

### Global changes in variability

With this analysis, we do not detect global changes in expression variability.
We next profile changes in mean expression and expression variability on a gene-specific level.
For this, we use a log$_2$ fold change threshold of 1 for mean expression testing and the default threshold of $\psi_0\approx0.41$ for differential variability testing.

```{r droplet-gene-specific-testing}
Droplet.Test <- BASiCS_TestDE(PSM.MCMC, SM.MCMC, EpsilonM = 1, 
                                     GroupLabel1 = "PSM", GroupLabel2 = "SM", 
                              Plot = FALSE, PlotOffset = FALSE)

# Differential expression
ggplot(Droplet.Test$TableMean) + 
  geom_point(aes(log(MeanOverall), MeanLog2FC, colour = ResultDiffMean)) +
  theme_minimal(base_size = 15) + 
  scale_colour_manual(name = "Differential expression", values = c("grey80", "#2166ac", "#b2182b")) +
  ylab(expression(mu[PSM]/mu[SM])) + xlab(expression(log(mu))) 

# Differential variability
ggplot(Droplet.Test$TableResDisp) + 
  geom_point(aes(log(MeanOverall), ResDispDistance, colour = ResultDiffResDisp)) +
  theme_minimal(base_size = 15) + 
  scale_colour_manual(name = "Differential variability", values = c("black", "grey80", "#542788", "#b35806")) +
  ylab(expression(epsilon[PSM]-epsilon[SM])) + xlab(expression(log(mu))) 
```

### Differential mean expression

We can now list the genes that were detected as differenitally expressed and differentially variable ordered by their difference in mean expression/variability.
We first focus on genes that are differentially expressed between the two cell types.

```{r gene-lists-mean}
# Highly expressed in somitic mesoderm
SM.mean <- Droplet.Test$TableMean[Droplet.Test$TableMean$ResultDiffMean == "SM+",]
SM.mean <- SM.mean[order(SM.mean$MeanLog2FC, decreasing = FALSE),]
SM.mean$Symbol <- genenames[SM.mean$GeneName,2]

# Highly expressed in pre-somitic mesoderm
PSM.mean <- Droplet.Test$TableMean[Droplet.Test$TableMean$ResultDiffMean == "PSM+",]
PSM.mean <- PSM.mean[order(PSM.mean$MeanLog2FC, decreasing = TRUE),]
PSM.mean$Symbol <- genenames[PSM.mean$GeneName,2]
```

We can next perform GO analysis on up- or down-regulated genes. 
First, we will perform GO analysis on somitic mesoderm specific genes.

```{r GO-analysis-mean-SM}
# Collect significan genes as 1 and all other as 0
SM.genes <- as.integer(Droplet.Test$TableMean$ResultDiffMean == "SM+")
names(SM.genes) <- Droplet.Test$TableMean$GeneName

# Build a Null distribution by correcting the gene length bias
pwf = nullp(SM.genes, "mm10", "ensGene", bias.data = genelength[names(SM.genes)])
GO.wall = goseq(pwf,"mm10","ensGene")
SM.GO = DataFrame(GO.wall[p.adjust(GO.wall$over_represented_pvalue, method="fdr") < 0.01,])

# Add genenames to the GO categories
all_genes <- vector(length = nrow(SM.GO))
for(j in 1:nrow(SM.GO)){
  allegs = get(SM.GO$category[j], org.Mm.egGO2ALLEGS)
  genes = unique(unlist(mget(allegs, org.Mm.egENSEMBL)))
  genes = as.character(genes[genes %in% SM.mean$GeneName])
  all_genes[j] <- paste(genes, collapse = ", ")
}
SM.GO$Genes <- all_genes
```

Now, we perform GO analysis on pre-somitic mesoderm specific genes

```{r GO-analysis-mean-PSM}
# Collect significan genes as 1 and all other as 0
PSM.genes <- as.integer(Droplet.Test$TableMean$ResultDiffMean == "PSM+")
names(PSM.genes) <- Droplet.Test$TableMean$GeneName

# Build a Null distribution by correcting the gene length bias
pwf = nullp(PSM.genes, "mm10", "ensGene", bias.data = genelength[names(PSM.genes)])
GO.wall = goseq(pwf,"mm10","ensGene")
PSM.GO = DataFrame(GO.wall[p.adjust(GO.wall$over_represented_pvalue, method="fdr") < 0.01,])

# Add genenames to the GO categories
all_genes <- vector(length = nrow(PSM.GO))
for(j in 1:nrow(PSM.GO)){
  allegs = get(PSM.GO$category[j], org.Mm.egGO2ALLEGS)
  genes = unique(unlist(mget(allegs, org.Mm.egENSEMBL)))
  genes = as.character(genes[genes %in% PSM.mean$GeneName])
  all_genes[j] <- paste(genes, collapse = ", ")
}
PSM.GO$Genes <- all_genes
```

To visualize the expression of individual genes, we can use the `scater` package.

```{r violin-plots}
# Expression of Fgf8 in both conditions
plotExpression(droplet.sce, features = genenames[genenames$external_gene_name == "Fgf8",1], 
               x = "cellType", colour_by = "cellType")
plotReducedDim(droplet.sce, use_dimred = "PCA", 
               colour_by = genenames[genenames$external_gene_name == "Fgf8",1])
```

Visualize one category in form of heatmap.

```{r, fig.height=7, fig.width=5}
for.heatmap <- logcounts(droplet.sce)[unlist(strsplit(PSM.GO[1,"Genes"], ", ")),]
colnames(for.heatmap) <- colData(droplet.sce)$cell

# Order cells by cell type
for.heatmap <- for.heatmap[,order(colnames(for.heatmap))]

# Order rows by log2FC
for.heatmap <- for.heatmap[order(PSM.mean[match(rownames(for.heatmap), PSM.mean$GeneName),"MeanLog2FC"],
                                 decreasing = TRUE),]

pheatmap(for.heatmap, cluster_cols = FALSE, show_colnames = FALSE, cluster_rows = FALSE,
         color = colorRampPalette(c("#053061", "#4393c3", "white", "#d6604d", "#67001f"))(100), 
         labels_row = genenames[rownames(for.heatmap),2],
         cellheight = 8, fontsize = 7, annotation_col = data.frame(row.names = colnames(for.heatmap),
                  cellType = sub("_.*", "", colnames(for.heatmap))), scale = "row")
```


### Differential variability testing

Next, we are interested in genes that change in variability between the two cell types.
To help interpretion of the result, we will split the genes into four categories.
These include:
* More variable in SM, highly expressed in SM
* More variable in SM, lowly expressed in SM
* More variable in PSM, highly expressed in PSM
* More variable in PSM, lowly expressed in SM

```{r}
gene.groups <- data.frame(Genename = Droplet.Test$TableResDisp$GeneName,
                          Symbol = genenames[Droplet.Test$TableResDisp$GeneName,2],
                          MeanLog2FC = Droplet.Test$TableMean$MeanLog2FC,
                          ResDispDistance = Droplet.Test$TableResDisp$ResDispDistance,
                          Regulation = paste(Droplet.Test$TableMean$ResultDiffMean, 
                                             Droplet.Test$TableResDisp$ResultDiffResDisp,
                                             sep = "_"))
gene.groups <- gene.groups[gene.groups$Regulation %in% 
                             c("SM+_SM+", "SM+_PSM+", "PSM+_PSM+","PSM+_SM+"),]

gene.groups[gene.groups$Regulation == "SM+_SM+",]
```

We can visualize individual genes using `scater`.

```{r violin-plots}
# Expression of Meox2 in both conditions
plotExpression(droplet.sce, features = genenames[genenames$external_gene_name == "Meox2",1], 
               x = "cellType", colour_by = "cellType") + 
  scale_fill_manual(values = c("coral4", "limegreen"))
plotReducedDim(droplet.sce, use_dimred = "PCA", 
               colour_by = genenames[genenames$external_gene_name == "Meox2",1], alpha = 1)
```

# Discussion 
This section is required if the paper does not include novel data or analyses.  It allows authors to briefly summarize the key points from the article.

# Session Info

```{r, session-info}
devtools::session_info()
```

# Software version

**Versions of all main Bioconductor packages**

# Data availability

**Links to Grun data and Ximenas data**
**Links to MCMC chains**


# Software availability

**Software: All software used in this workflow is available as part of Bioconductor X.Y**
**The source code of this workflow is available from: YYY**
**Link to Github release version, source code**
**License: ask Aaron**

This section will be generated by the Editorial Office before publication. Authors are asked to provide some initial information to assist the Editorial Office, as detailed below.

1. URL link to where the software can be downloaded from or used by a non-coder (AUTHOR TO PROVIDE; optional)
2. URL link to the author's version control system repository containing the source code (AUTHOR TO PROVIDE; required)
3. Link to source code as at time of publication (*F1000Research* TO GENERATE)
4. Link to archived source code as at time of publication (*F1000Research* TO GENERATE)
5. Software license (AUTHOR TO PROVIDE; required)


# Author information
In order to give appropriate credit to each author of an article, the individual contributions of each author to the manuscript should be detailed in this section. We recommend using author initials and then stating briefly how they contributed.

# Competing interests
All financial, personal, or professional competing interests for any of the authors that could be construed to unduly influence the content of the article must be disclosed and will be displayed alongside the article. If there are no relevant competing interests to declare, please add the following: 'No competing interests were disclosed'.

# Grant information
Please state who funded the work discussed in this article, whether it is your employer, a grant funder etc. Please do not list funding that you have that is not relevant to this specific piece of research. For each funder, please state the funderâs name, the grant number where applicable, and the individual to whom the grant was assigned. If your work was not funded by any grants, please include the line: 'The author(s) declared that no grants were involved in supporting this work.'

# Acknowledgments
This section should acknowledge anyone who contributed to the research or the article but who does not qualify as an author based on the criteria provided earlier (e.g. someone or an organization that provided writing assistance). Please state how they contributed; authors should obtain permission to acknowledge from all those mentioned in the Acknowledgments section.

Please do not list grant funding in this section.