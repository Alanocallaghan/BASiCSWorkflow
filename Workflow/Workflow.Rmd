---
title: "A BASiCS workflow for expression variability analysis using scRNA-Seq data"
author:
- name: Nils Eling
  affiliation: 
  - &EBI European Molecular Biology Laboratory, European Bioinformatics Institute, Wellcome Trust Genome Campus, Hinxton, Cambridge CB10 1SD, UK
  - &CRUK Cancer Research UK Cambridge Institute, University of Cambridge, Li Ka Shing Centre, Cambridge, CB2 0RE, UK
- name: Alan O'Callaghan
  affiliation: 
  - &MRC MRC Human Genetics Unit, Institute of Genetics & Molecular Medicine, University of Edinburgh, Western General Hospital, Crewe Road, Edinburgh, EH4 2XU, UK
- name: John C. Marioni
  affiliation: 
  - *EBI
  - *CRUK
- name: Catalina A. Vallejos
  affiliation: 
  - *MRC 
  - The Alan Turing Institute, British Library, 96 Euston Road, London, NW1 2DB, UK
  email: catalina.vallejos@igmm.ed.ac.uk
abstract: Cell-to-cell variability in gene expression is an inherent feature of biological systems. Single-cell RNA sequencing can be used to quantify this heterogeneity, but it is prone to strong technical noise. Here, we describe a computational workflow that uses the BASiCS Bioconductor package to robustly quantify cell-to-cell expression variability within and between known cell populations (e.g.~experimental conditions or cell types). We illustrate how BASiCS can identify highly and lowly variable genes within a cell population. Furthermore, we also show how BASiCS can highlight changes in gene expression variability between cell populations, while avoiding confounding effects related to technical noise or changes in overall abundance. Using publicly available datasets, we guide users through a complete pipeline which includes preliminary steps for quality control and data exploration using the scater Bioconductor package. Two case studies are described. The first uses data generated using the Fluidigm\@ C1 system, in which spike-in RNA molecules are used in order to quantify technical noise.The second dataset was generated using a droplet-based system, for which spike-in RNA is not available. The latter analysis provides an example in which differential variability testing reveals insights regarding a possible early cell fate commitment process. 

#Abstracts should be up to 300 words and provide a succinct summary of the article. Although the abstract should explain why the article might be interesting, care should be taken not to inappropriately over-emphasise the importance of the work described in the article. Citations should not be used in the abstract, and the use of abbreviations should be minimized.
keywords: Single-cell RNA sequencing, expression variability, noise, differential expression testing
bibliography: BASiCSworkflow.bib
output: BiocWorkflowTools::f1000_article
#output:
# BiocStyle::html_document:
#   fig_caption: true
#   self_contained: yes
#vignette: >
#  %\VignetteIndexEntry{A BASiCS workflow for expression variability analysis using scRNAseq data}
#  %\VignetteEngine{knitr::rmarkdown}
#  %\VignetteEncoding{UTF-8}
---

```{r setup_knitr, include = FALSE, cache = FALSE}
library("BiocStyle")
## Decide whether to display parts for BioC (TRUE) or F1000 (FALSE)
on.bioc <- TRUE
library("knitr")
# Use fig.width = 7 for html and fig.width = 6 for pdf
fig.width <- ifelse(on.bioc, 7, 6)
knitr::opts_chunk$set(cache = 2, warning = FALSE, message = FALSE, error = FALSE,
  cache.path = "cache/", fig.path = "figure/", fig.width = fig.width)
```

# Introduction

<!--- This paragraph: scRNA-Seq and the different types of heterogeneity --->
<!--- Ref to clustering removed, as the focus is on the types of heterogeneity,
not in the analysis. Check if @Rosenberg2018 reference is still relevant --> 
Single-cell RNA-sequencing (scRNA-Seq) is the leading technology to study genome-wide transcriptional heterogeneity in cell populations that remains otherwise undetected in bulk experiments [@Stegle2015]. 
Its applications range from uncovering novel cell types in immunity [@Lonnberg2017, @Villani2017] and development [@Ibarra-Soria2018a, @Wagner2018] to dissecting the mechanism 
for cell-to-cell differences in expression [@Goolam2016] or understanding differentiation processes [@Proserpio2016]. 
Within a population of cells, transcriptional heterogeneity can be due a mixture of possible causes. 
On the broadest level, this heterogeneity can reflect the presence of cell subtypes with distinct expression profiles *I would cite Kieselev NRG here*.
More subtle variation within a seemingly homogeneous cell population can be due to deterministic or stochastic events, the later being referred to as 'noise' [@Elowitz2002]. 
<!--- edited until here ---> 
Classically, extrinsic noise is defined as fluctuations in ... differences in dynamic states (cell size, cell cycle, metabolism, intra- and inter-cellular signalling) while intrinsic noise effects single promoters via mutations, epigenetic modifications and nucleosome positioning [@Faure2017, @Eberwine2015].
However, *Describe molecular phenotypic variability here...*

<!--- This paragraph: technical noise, normalisation and hvg/lvg analyses ---> 
Moreover, technical noise inflates the overall variability in gene expression [@Brennecke2013].
To account for high amounts of technical noise that affects scRNA-seq data, external RNA spike-in molecules (ERCCs) [@Rna2005] can be added to the experiment before sequencing. 
Fitting the variance-mean dependency of the ERCCs allows the statistical detection of genes with higher dispersion in expression than the technical background [@Brennecke2013]. 
This idea has been expanded to estimate cell specific normalisation factors in parallel within the BASiCS model. 
Total variability can be decomposed into a technical and biological part by incorporating ERCC reads [@Vallejos2015]. 

<!--- This paragraph: differential analyses ---> 
Since the era of bulk RNA sequencing, methods for differential expression testing of transcript counts across two conditions have been developed [@Anders2010;@Robinson2009]. 
Due to zero inflation in scRNA-seq data, new approaches were developed for differential expression testing in scRNA-seq data [@Katayama2013;@Kharchenko2014;@Delmans2016]. 
In contrast to bulk samples, scRNA-seq allows the characterization of gene expression variability across a population of cells. 
To compare changes in transcriptional variability, the BASiCS package has been expanded to include differential mean expression and differential variability testing. 
In this setting, BASiCS uses the over-dispersion after correcting for technical noise as proxy for biolgocial variability [@Vallejos2016a]. 
Due to a strong confounding between mean expression and over-dispersion, BASiCS has been extended to model this relationship and capture residual over-dispersion estimates that show no correlation to mean expression. 
Therefore, it is possible to test changes in mean expression in parallel to changes in variability [@Eling2018]. 

<!--- This paragraph: outline ---> 
Here we present a computational workflow for differential expression and differential variability testing of scRNA-seq data using the previously published BASiCS package [@Vallejos2015;@Vallejos2016a;@Eling2017] implemented in the statistical computing language R. 
The analysis starts with a raw transcript counts matrix after removal of low-quality cells. 
A full quality control process is explained elsewhere [@McCarthy2017].
We will first focus on gene filtering, generating a SingleCellExpression object to use within BASiCS, and explain how to run and validate the convergence of Markov-Chain Monte Carlo simulations.
Additionally, we will use two examples (Cel-Seq [@Grun2014] and droplet-based scRNAseq data [@Ibarra-Soria2018]) to exemplify statistical detection of highly variable, differentially expressed and differentially variable genes in different conditions. 

*Discuss and cite similar workflows: scran, Mark Robinson, the chapter/workflow that Kim published*

# Methods

- Explain BASiCS from a users perspective (4 different cases)
- Coda package for Markov Chain Monte Carlo (MCMC) visualization, MCMC convergency analysis, effective sample size
- Explain scater for preprocessing (highlight: QC, pre-normalization and visualization)
- scran for alternative measures e.g. DM and CV2 calculation
- GO analysis

## Outline

**Mike Love, Charlotte Sonesone, Rob Patron**
**We explain the workflow outline.**
**This has to be very easy to understand.**

## Operation

**Here we mention the version of R and Bioconductor that we are using.** 
*Specifically name the Bioconductor packages that we are using**

## Prerequisites 

*Move this section into the code once the workflow is done*

*And introduce each package that was used*

The following R packages and data objects are needed throughout the workflow.
We introduce them at this point as convinience and will link to this section whenever these objects are used.

```{r libraries}
library("BASiCS")
library("scater")
library("SingleCellExperiment")
library("scran")
library("coda")
library("goseq")
library("viridis")
library("pheatmap")
library("ggplot2")
library("biomaRt")
library("EnsDb.Mmusculus.v79")
```

To obtain gene annotations used in thiw workflow, we used the `biomaRt` package.
The **Mus musculus** gene ids and gene names can be directly accessed using the following code: 

```{r obtain-gene-symbols, message=FALSE, echo=FALSE, eval=FALSE}
ensembl <- useMart("ensembl")
ensembl <- useDataset(dataset = "mmusculus_gene_ensembl", mart = ensembl)
genenames <- getBM(attributes = c("ensembl_gene_id", "external_gene_name"),
                   mart = ensembl)
rownames(genenames) <- genenames$ensembl_gene_id
```

To perform gene ontology (GO) analysis, we collect the length for each gene.
This can be extracted from the `EnsDb.Mmusculus.v79` package.

```{r, message=FALSE, echo=FALSE, eval=FALSE}
exons.list <- exonsBy(EnsDb.Mmusculus.v79, by = "gene")
genelength <- unlist(lapply(exons.list, function(x) sum(width(reduce(x)))))
```

# C1 Fluidigm data: Analysis of naive CD4^+^ T cells

In the first case, we use scRNA-Seq data of CD4+ T cells, which were processed using the C1 Single-Cell Auto Prep System (Fluidigm®). 
Martinez-Jimenez _et al._ collected naive and activated CD4^+^ from young and old animals across two muse strains to profile changes in expression variability that occur during organismal ageing [@Martinez-jimenez2017].
Naive or effector memory CD4^+^ T cells were extracted from spleens of young or old animals and filtered using either a MACS- or FACS-based approach (MACS-purified Naive, FACS-purified Naive or FACS-purified Effector Memory).
Naive as well as CD4^+^ T cells that were activated by 3 hours of _in vitro_ antibody stimulation were processed using the C1 Fluidigm® system to capture and lyse cells, and to reverse transcript and amplify mRNA prior to sequencing.
Cells were isolated from B6 (C57BL/6J, _Mus musculus domesticus_) and CAST (_Mus musculus castaneus_) animals to profile the evolutionary conservation of transcriptional dynamics during ageing.
External spike-in RNA has been added to quantify technical variability across all cells.
All experiments were performed in replicates (also referred to as batches) to control for batch effects.

In the first instance, the data needs to be obtained, processed and filtered before running the BASiCS model.

## Creating the input data

### Obtaining the data

The raw counts of the full dataset can be obtain from ArrayExpress under the accession number [E-MTAB-4888](https://www.ebi.ac.uk/arrayexpress/experiments/E-MTAB-4888/).
The column names contain the library identifier of the original experiment while the row names of the matrix store the individual gene names. 
The dataset contains reads mapping to ERCC spike-in genes [@Rna2005], which `BASiCS` uses to estimate and remove technical noise.

```{r naive-data}
if(!file.exists("raw_data.txt")){
  # Download raw counts file
  download.file("https://www.ebi.ac.uk/arrayexpress/files/E-MTAB-4888/E-MTAB-4888.processed.1.zip", 
                destfile = "raw_data.txt.zip")
  # Unzip file
  unzip("raw_data.txt.zip")
  file.remove("raw_data.txt.zip")
}
CD4.raw <- read.table("raw_data.txt", header = TRUE, sep = "\t")

# Show row and column names
head(colnames(CD4.raw))
head(rownames(CD4.raw))

# ERCC spike-in genes
rownames(CD4.raw)[grepl("ERCC", rownames(CD4.raw))]
```

To link the library identifier to the experimental condition, the authors provide a metadata file that can be accessed online.
We will remove the spaces in the `Individual` column since these will be used as batch information later on.

```{r selecting-serum-cells}
if(!file.exists("metadata_file.txt")){
  # Download raw counts file
  download.file("https://www.ebi.ac.uk/arrayexpress/files/E-MTAB-4888/E-MTAB-4888.additional.1.zip", 
                destfile = "metadata.txt.zip")
  # Unzip file
  unzip("metadata.txt.zip")
  file.remove("metadata.txt.zip")
}
CD4.metadata <- read.table("metadata_file.txt", header = TRUE, sep = "\t")
rownames(CD4.metadata) <- CD4.metadata$X

# Remove spaces
#CD4.metadata$Individuals <- sub(" ", "_", CD4.metadata$Individuals)
#CD4.metadata$Individuals <- sub(" ", "_", CD4.metadata$Individuals)

# Show metadata entries
head(CD4.metadata)
```

### Filtering the data

For further down-stream analysis, we select naive and activated CD4^+^ T cells from young B6 animals that were obtained using MACS-based cell selection.
It is crucial that proper quality control (QC) and gene filtering is performed before running BASiCS, and, in general, before performing meaningful computational analysis on biological data.

We will first select naive and activated CD4^+^ T cells.
For convenience, we will generate a `Biocpkg("SingleCellExperiment")` [@Lun2018SCE] that contains all cells and that stores cell- and gene-specific metadata.
Furthermore, this object stores gene-specific information whether or not a gene is of biological (endogeneous) or technical (spike-in) origin.

```{r CD4-SCE-object}
# Load library
library("SingleCellExperiment")

# Generate the SingleCellExperiment object
sce.CD4_all <- SingleCellExperiment(assays = list(counts = as.matrix(CD4.raw)),
                                    colData = CD4.metadata[colnames(CD4.raw), ])

# Store spike-in information
isSpike(sce.CD4_all, "ERCC") <- which(grepl("ERCC", rownames(sce.CD4_all)))

# Select naive and activated CD4+ T cells of young B6 animals
sce.naive_active <- sce.CD4_all[, sce.CD4_all$Strain == "Mus musculus domesticus" &
                                  sce.CD4_all$Age == "Young" &
                                  sce.CD4_all$Celltype == "MACS-purified Naive"]
```

Prior to quality control, we will remove all genes that are not detected in at least 2 cells.
We further remove genes that are not expressed with an average count of 1 across all cells.

```{r gene-selection}
# Remove genes
ind_expressed <- apply(counts(sce.naive_active), 1, function(n) sum(n > 0)) > 1 &
                  rowMeans(counts(sce.naive_active)) >= 1
sce.naive_active <- sce.naive_active[ind_expressed, ]
```

In the next step, we will use the `Biocpkg("scran")` and `Biocpkg("scater")` for initial normalization and visualization [@Lun2016,@McCarthy2017].
In line with the normalization strategy of BASiCS, we use the spike-in reads for normalization.

```{r}
# Load libraries
library("scran")
library("scater")

# Pre-normalization of data for visualization purposes
sce.naive_active <- computeSpikeFactors(sce.naive_active)
sce.naive_active <- normalize(sce.naive_active)
```

The `Biocpkg("SimpleSingleCell")` workflow provides an extensive overview on important aspects of how to perform low-level analysis of scRNA-Seq data, including quality control [@Lun2016].
In the original publication, the authors removed empty capture sites and sites which contained multiple cells or debris as observed by visual inspection. 
Furthermore, they removed cells which had fewer than 1,000,000 total reads, cells where less than 20% of reads mapped to endogenous genes, cells in which less than 1,250 or more than 3,000 genes were detected and cells with more than 10% or less than 0.5% reads mapping to mitochondrial genes [@Martinez-jimenez2017].
Since these data have been quality filtered in the original publication, we will soley visualize metrics that can be used to distinguish low quality cells.
These metrics include (among others): number of endogeneous genes detected per cell, total number of reads per cell, the fraction of reads mapping to spike-in and endogeneous genes.

```{r}
# Calculate quality metrics
sce.naive_active <- calculateQCMetrics(sce.naive_active)

# Calcualte PCA
sce.naive_active <- runPCA(sce.naive_active)

# Visualize the conditions and batch structure
plotPCA(sce.naive_active, colour_by = "Stimulus")
plotPCA(sce.naive_active, colour_by = "Individuals")

# Visualize number of endogeneous genes detected
plotPCA(sce.naive_active, colour_by = "total_features_by_counts_endogenous")

# Visualize log10-transformed total number of counts
plotPCA(sce.naive_active, colour_by = "log10_total_counts")

# Plot the fraction of reads mapping to spike-ins 
# versus the number of reads mapping to endogeneous genes
ggplot(as.data.frame(colData(sce.naive_active))) +
  geom_point(aes(log10_total_counts_endogenous, log10_total_counts_ERCC))

# Remove two cells that appear to be outliers
ind_retain <- sce.naive_active$log10_total_counts_endogenous > 5.8
sce.naive_active <- sce.naive_active[, ind_retain]
```

The data splits into two conditions: naive and activated CD4^+^ T cells.
Furthermore, we do not detect batch effects or outlier cells based on PCA visualization.
Nevertheless, we removed two cells that showed unusually low number of reads mapping to endogeneous genes.
It is crucial that an in-depth quality control is performed to remove low-quality or outlying cells, but also to understand where possible confounding effect arise that can influence the interpretation of variability measures.

### Calculating the molecule count for spike-in genes

BASiCS requires the actual molecule count of the spike-in genes that were added per well.
For this, a table of the spike-in concentrations can be downloaded from: [ERCC spike-in](https://www.thermofisher.com/order/catalog/product/4456740).
The file contains the concentrations of 2 ERCC spike-in mixes.

The lysis mix contains a 1:50,000 dilution of the ERCC mix 1 [@Martinez-jimenez2017].

```{r spike-in_download}
# Read in the spike-in concentrations
ERCC.conc <- read.table(url("https://assets.thermofisher.com/TFS-Assets/LSG/manuals/cms_095046.txt"), 
                         sep = "\t", header = TRUE)
```

The concentration is given in units of attomoles per \mu{}l. 
We will first calculate the concentration in moles per \mu{}l

```{r}
# Moles per micro litre
ERCC.mmul <- ERCC.conc$concentration.in.Mix.1..attomoles.ul. * (10^(-18))
```

From this, we can calculate the molecule count per \mu{}l.
1 mole is equal to 6.02214076\*(10^23) molecules.

```{r}
ERCC.countmul <- ERCC.mmul*(6.02214076*(10^23))
```

The authors diluted this mix by 1:50,000.
The actual molecule number of spike-ins can therefore be calculated per well:

```{r}
ERCC.count <- ERCC.countmul / 50000
```

We can now use the molecule count to prepare the BASiCS data object.
To incorporate the ERCC molecule counts within the `Biocpkg("SingleCellExperiment")` object that BASiCS requires, the first column must contain the names associated to the spike-in genes. 
The second column must contain the input number of molecules for the spike-in genes (amount per well).

```{r spike-info}
# Prepare the data.frame
ERCC.count <- data.frame(row.names = ERCC.conc$ERCC.ID,
                         Names = ERCC.conc$ERCC.ID,
                         count = ERCC.count)
```

## Single condition example: Naive CD4^+^ T cells

To highlight the use of BASiCS and the quantification of variability measures in the single-condition case, we select naive CD4^+^ T cells of young B6 animals.

### Preparing the BASiCS data object

The BASiCS Data object is an object of the class `Biocpkg("SingleCellExperiment")` [@Lun2018SCE].
The `newBASiCS_Data` function can be used to create the required `SingleCellExperiment` object based on the following information:

* Counts: a matrix of raw expression counts with dimensions $q$ times $n$ where $q$ is the number of genes (technical + biological) and $n$ is the number of cells. Gene names must be stored as row names of the counts matrix.

* Tech: a vector of TRUE/FALSE elements with length $q$. If Tech[i] = FALSE the gene i is biological; otherwise the gene is spike-in. This vector must be specified in the same order of genes as in the counts matrix.

* SpikeInfo: a data.frame with $q-q_0$ rows where $q_0$ is the number of biological genes. First column must contain the names associated to the spike-in genes. The second column must contain the input number of molecules for the spike-in genes (amount per cell).

* BatchInfo (optional argument): vector of length $n$ to indicate batch structure in situations where cells have been processed using multiple batches.

We will first select the naive cells from the `SingleCellExperiment` object that was generated above.

```{r SCE-naive}
ind_stimulated <- sce.naive_active$Stimulus == "Unstimulated"
sce.naive <- sce.naive_active[, ind_stimulated]
```

Next, we will use the `newBASiCS_Data` function to re-generate the `SingleCellExperiment` object for the use with BASiCS.

```{r Data-naive}
# Here is the first time that we use BASiCS
library("BASiCS")

# Select the ERCC spike-ins of the dataset
ind_spike <- rownames(sce.naive)[isSpike(sce.naive)]
SpikeInput <- ERCC.count[ind_spike, ]

# Generate the SingleCellExperiment object
Data.naive <- newBASiCS_Data(Counts = counts(sce.naive), 
                       Tech = isSpike(sce.naive), 
                       SpikeInfo = SpikeInput, 
                       BatchInfo = sce.naive$Individuals)
Data.naive
```

Alternatively, when using data the contain spike-in genes, the original `SingleCellExperiment` object can be extended by simply specifying a `BatchInfo` slot in the `colData` object and by adding the `SpikeInfo` object to the `metadata` slot.

```{r Data-naive-alternative}
Data.naive <- sce.naive
colData(Data.naive)$BatchInfo <- colData(sce.naive)$Individuals
metadata(Data.naive)$SpikeInput <- SpikeInput$count
```

In the next step, the MCMC sampler can be run to generate posterior estimates of model parameters

### Running the MCMC

It is recommended to run the `BASiCS_MCMC` sampler for at least 40,000 iterations to assure convergence.
However, if datasets are large and each condition contains hundreds of cells from a homogeneous population, BASiCS can be run with fewer (e.g. 20,000) iterations.
Furthermore, `BASiCS_MCMC` can be run with very few (e.g 1,000) iterations to test whether the sampler breaks.

Here, we run the MCMC sampler for 40,000 iterations, using an initial 20,000 iterations as burn in an a thinning step of 20 iterations.
Since the dataset contains spike-in genes, we run the sampler with `WithSpikes = TRUE` and we also want to correct for the mean-variance trend using `Regression = TRUE`.
For further information see *link to Methods*

```{r MCMC-naive, echo=FALSE, eval=FALSE}
MCMC.naive <- BASiCS_MCMC(Data = Data.naive, 
                          N = 40000, 
                          Thin = 20, 
                          Burn = 20000, 
                          Regression = TRUE, 
                          WithSpikes = TRUE)
```

This sampler runs for *XYZ minutes* on a 1.4 GHz Intel Core i5 procesor with 4GB RAM and produces a `BASiCS_Chain` data object.
For convenience, the MCMC chain can be obtained online at [https://jmlab-gitlab.cruk.cam.ac.uk/publications/BASiCSWorkflow2018](https://jmlab-gitlab.cruk.cam.ac.uk/publications/BASiCSWorkflow2018).

```{r download-chain-naive}
MCMC.naive <- readRDS(file = url("https://jmlab-gitlab.cruk.cam.ac.uk/publications/BASiCSWorkflow2018/raw/master/MCMCs/MCMC_naive.rds"))
```

In the next step, the convergence of the sampler needs to be assessed.
To obtain a summary of the MCMC sampler, BASiCS provides the `Summary` method.

```{r Summary}
Summary.naive <- Summary(MCMC.naive)
```

### Validating the MCMC convergence

There are multiple ways of how the convergence of the chains can be assessed *refs*.
The `CRANpkg("coda")` contains diagnostic and plot functions for this task *ref*.
Here, we opt for a simple visual assessment to highlight the convergenece of the chains.
To select individual chains from the `BASiCS_Chain` onject, we use the `displayChainBASiCS` function.
These chains need to be converted to an `mcmc` object for the use with `coda`.

```{r convergence-naive}
library("coda")

# Convergence of mean expression parameters
plot(mcmc(displayChainBASiCS(MCMC.naive, Param = "mu")[, 1]))
plot(mcmc(displayChainBASiCS(MCMC.naive, Param = "mu")[, 1000]))
plot(mcmc(displayChainBASiCS(MCMC.naive, Param = "mu")[, 10000]))

# Convergence of over-dispersion parameters
plot(mcmc(displayChainBASiCS(MCMC.naive, Param = "delta")[, 1]))
plot(mcmc(displayChainBASiCS(MCMC.naive, Param = "delta")[, 1000]))
plot(mcmc(displayChainBASiCS(MCMC.naive, Param = "delta")[, 10000]))

# Convergence of residual over-dispersion parameters
plot(mcmc(displayChainBASiCS(MCMC.naive, Param = "epsilon")[, 1]))
plot(mcmc(displayChainBASiCS(MCMC.naive, Param = "epsilon")[, 1000]))
plot(mcmc(displayChainBASiCS(MCMC.naive, Param = "epsilon")[, 10000]))

# Convergence of mRNA capture efficiency parameters
plot(mcmc(displayChainBASiCS(MCMC.naive, Param = "s")[, 1]))
plot(mcmc(displayChainBASiCS(MCMC.naive, Param = "s")[, 10]))
plot(mcmc(displayChainBASiCS(MCMC.naive, Param = "s")[, 50]))

# Convergence of mRNA content parameters
plot(mcmc(displayChainBASiCS(MCMC.naive, Param = "phi")[, 1]))
plot(mcmc(displayChainBASiCS(MCMC.naive, Param = "phi")[, 10]))
plot(mcmc(displayChainBASiCS(MCMC.naive, Param = "phi")[, 50]))

# Convergence of batch-specific global noise parameters
plot(mcmc(displayChainBASiCS(MCMC.naive, Param = "theta")[, 1]))
plot(mcmc(displayChainBASiCS(MCMC.naive, Param = "theta")[, 2]))
```

The visual inspection shows that all chains converged, which is the prerequisite for further downstream analysis.


We can also assess the quality of the samples generated by assessing 
the effective sample size of the parameters. In Bioconductor 3.9 and onward,
BASiCS provides several functions to visualise this measure of ,
in particular `BASiCS_diagHist` and `BASiCS_diagPlot`.

*explain + cite ESS*
*why does it fail for all parameters?*
*examine which genes have low ESS, exclude from further analysis*

```{r convergence-ess}
BASiCS_diagHist(MCMC.naive)

BASiCS_diagHist(MCMC.naive, Param = "mu")
BASiCS_diagHist(MCMC.naive, Param = "delta")

BASiCS_diagPlot(MCMC.naive, Param = "mu")
BASiCS_diagPlot(MCMC.naive, Param = "delta")

```
## Downstream analysis

In this section, we will highlight the use of BASiCS when cells of a single condition are analysed.
The downstream analysis includes: normalization, variance decomposition, detection of highly and lowly variable genes and the use of gene-specific parameters as interpretable variability measures.
Furthermore, we will compare the results in the individual steps with results obtained using the `Biocpkg("scran")`.

### Normalization

Posterior estimates of cell-specific parameters can be used to normalize the data and correct for biases in mRNA content *ref Vallejos 2017*.
To perform normalization, BASiCS provides the `BASiCS_DenoisedCounts` and the `BASiCS_DenoisedRates` functions. 
*Not sure if we should talk about the DenoiseRates function here*.
These functions take the `SingleCellExperiment` and `BASiCS_Chain` objects as inputs.

```{r normalization-naive}
counts.denoised <- BASiCS_DenoisedRates(Data = Data.naive, Chain = MCMC.naive)
```

These normalized counts can be further used for dimensionality reduction and clustering as explained elsewhere *ref,ref*.

### Variance decomposition

*The results of the variance decomposition and HVG analysis appears a bit weird here...*

Similar to normalization, the posterior estimates can be used to decompose the overall variance of the data into a technical, biological and Poisson sampling noise component [@Vallejos2015BASiCS].
For this, BASiCS offers the `BASiCS_VarianceDecomp` function that takes the `BASiCS_Chain` object and by default orders genes based on their value for biological variance.
Furthermore, this function calculates the variance components per batch.

```{r variance-decomposition-naive}
# Perform variance decomposition
VarDecomp <- BASiCS::BASiCS_VarianceDecomp(MCMC.naive)
head(VarDecomp)

# Plot the biological part of total variance
ggplot(VarDecomp) +
  geom_point(aes(seq(1, nrow(VarDecomp)), BioVarGlobal))
```

This analysis can be used to select genes with high biological variability for analysis such as clustering and dimensionality reduction *refs to HVG gene selection*.

### Lowly-highly variable genes

As alternative to the analysis described above, BASiCS offers a function to select genes with large and small biological variance.
The `BASiCS_DetectHVG` and `BASiCS_DetectLVG` functions take the `BASiCS_Chain` object and a threshold for the biological variance component as input. 
As seen in Figure *link to privious plot*, the biological component of genes expressed in naive CD4^+^ T cells is large and we select a threshold of larger 99% to detect highly variable genes (HVG).
To detect lowly variable genes, we chose a threshold of smaller 80% to find lowly variable genes.

```{r naive-HVG-LVG}
# Highly variable genes
HVG <- BASiCS_DetectHVG(MCMC.naive, VarThreshold = 0.99)

# Lowly variable genes
LVG <- BASiCS_DetectLVG(MCMC.naive, VarThreshold = 0.8)
```

This analysis results in the detection of *XYZ* highly variable genes and *XYZ* lowly variable genes.

The `Biocpkg("scran")` provides similar functions to detect HVGs and we can compare the results of both methods.
`scran` first fits a smooth regression between the variance of the log-transformed expression of the spike-in transcripts and their mean abundance using the `trendVar` function.
Afterwards, the `decomposeVar` function decomposes the gene-specific variance into a biological and technical component.

```{r HVG-LVG-scran}
# Fit the mean-variance trend
var.fit <- scran::trendVar(sce.naive, use.spikes = TRUE) 

# Variance decomposition
var.out <- scran::decomposeVar(sce.naive, var.fit)
```

As proposed by the `SimpleSingleCell` workflow, the HVGs are described as displaying a biolgical variance component of larger than 0.5 while controlling the FDR to 5% [@Lun2016].
*Make sure this is still in the current version of SimpleSingleCell*.
We can then compare the the overlap of the HVG identified by scran and by BASiCS.

```{r scran-HVG}
ind_hvg <- which(var.out$FDR <= 0.05 & var.out$bio >= 0.5)
hvg.out <- var.out[ind_hvg, ] 
hvg.out <- hvg.out[order(hvg.out$bio, decreasing = TRUE), ] 
nrow(hvg.out)

# Intersection between BASiCS and scran HVG
length(intersect(rownames(hvg.out), HVG$Table$GeneName))
```

All *XYZ* HVG genes of scran are among the HVGs identified by BASiCS.

### Mean-variance trend

Numerous studies have highlighted the relationship between gene-specific variability measures such as the squared coefficient of variation and mean abundance *ref,ref,ref*.
BASiCS provides the `BASiCS_showFit` function that plots the gene-specific over-dispersion parameters (delta) versus mean expression parameters (mu). 

```{r naive-fit}
BASiCS_showFit(MCMC.naive)
```

Here, we observe that the over-dispersion estimates are negatively associated with mean expression.
However, by performing the regression between over-dispersion and mean expression, we can correct for this trend and obtain variability measures that show no correlation with mean expression [@Eling2018].
The purple points in the plot indicate genes that are not expressed in at least 2 cells.
BASiCS automatically excludes these genes due to challenges in interpreting variability estimates and changes in variability for genes that are only expressed in one cell.

We can now compare the gene-specific variability measures (over-dispersion and residual over-dispersion) to previously used measures to quantify cell-to-cell expression variability [@Brennecke2013,Ola 2015].

### Comparison to variance, Fano factor, CV2, and DM

Widely used measures of expression variability include the variance [@Shalek2014], the Fano factor (variance divided by mean expression) *refs* and the coefficient of variation (CV, variance divided by squared mean expression) *refs*. 
Here, we will highlight the mean-variance realtionship for each variability measures.
For this analysis, we exclude genes that are not expressed in at least 2 cells.
These genes can be identified in the `displayChainBASiCS(MCMC.naive, Param = "epsilon")` to contain `NA`.

```{r variability-measures}
# Exclude genes
eps_not_na <- !is.na(displayChainBASiCS(MCMC.naive, Param = "epsilon")[1, ])
counts.denoised <- counts.denoised[eps_not_na, ]

# Variance
var.genes <- apply(counts.denoised, 1, var)
mean.genes <- apply(counts.denoised, 1, mean)

ggplot(data.frame(variance = var.genes,
                  mean = mean.genes)) +
  geom_point(aes(log(mean), log(variance)))

# Fano factor
ggplot(data.frame(fano = var.genes/mean.genes,
                  mean = mean.genes)) +
  geom_point(aes(log(mean), log(fano)))

# Squared coefficient of variation
ggplot(data.frame(CV2 = var.genes/mean.genes^2,
                  mean = mean.genes)) +
  geom_point(aes(log(mean), log(CV2)))
```

We see that all measures correlate with mean expression.
The same is true for the over-dispersion parameters as estimated by BASiCS as shown below.
Again, for this comparison, we exclude genes that do not show expression in at least 2 cells

```{r CV-comparison-BASiCS}
# Remove genes
eps_not_na <- !is.na(displaySummaryBASiCS(Summary.naive, Param = "epsilon")[, "median"])
mu.naive <- displaySummaryBASiCS(Summary.naive, Param = "mu")[eps_not_na, ]
delta.naive <- displaySummaryBASiCS(Summary.naive, Param = "delta")[eps_not_na, ]

# Over-dispersion versus mean expression
ggplot(data.frame(mu = mu.naive[, "median"],
                  delta = delta.naive[, "median"])) +
  geom_point(aes(log(mu), log(delta)))

# Compare delta to CV2
ggplot(data.frame(CV2 = var.genes/mean.genes^2,
                  delta = delta.naive[, "median"])) +
  geom_point(aes(log(CV2), log(delta))) 
```

The over-dispersion parameters estimated using BASiCS show strong correlation with the CV2. 
Recently, we extended BASiCS to avoid the mean-variability relationship by performing an internal regression between the over-dispersion and mean expression parameters (as visualized in figure *Figure showFit*).
Similarly, Kolodziejczyk _et al._ used the distance to a rolling median (DM) along the mean-variability trend to correct for this confounding factor [@Kolodziejczyk2015cell].
Here, we highlight how to obtain the residual variability estimates using `BASiCS` and `scran`.

```{r}
# Residual over-dispersion estimates
epsilon.naive <- displaySummaryBASiCS(Summary.naive, Param = "epsilon")[eps_not_na, ]

# Residual over-dispersion versus mean expression
ggplot(data.frame(mu = mu.naive[, "median"],
                  epsilon = epsilon.naive[, "median"])) +
  geom_point(aes(log(mu), epsilon))

# DM values
DM.naive <- scran::DM(mean = mean.genes, cv2 = var.genes/mean.genes^2)

# DM versus mean expression
ggplot(data.frame(mean = mean.genes,
                  DM = DM.naive)) +
  geom_point(aes(log(mean), DM))

# Compare residual over-dispersion and DM
ggplot(data.frame(epsilon = epsilon.naive[, "median"],
                  DM = DM.naive)) + 
  geom_point(aes(epsilon, DM))
```

Neither the DM nor the residual over-dispersion estimates show association with mean expression.
Furthermore, the mean-independent variability measures display high correlation.
These measures can be used to associate genomic features [@Morgan2018,@Faure2018] or transcriptional dynamics [@Antolovic2017] to gene expression variability.
While the DM is calculated as a point estimate, BASiCS stores each posterior sample within the `BASiCS_Chain` object.
They can be accessed using the `displayChain` function, which displays cell- or gene-specific samples in form of a matrix where each column contains cell- or gene-specific paramters and rows contain the MCMC samples.

```{r individual-samples}
displayChainBASiCS(MCMC.naive, Param = "epsilon")[1:10, 1:10]
```

*Not sure if we need this*
By testing a certain association (for example between CpG island length and variability [@Morgan2018]) for each MCMC sample, one can generate a _post-hoc_ posterior distribution of the test statistic. 

The workflow so far highlights the use of BASiCS for analysing cells of a single condtion.

# Differential testing between naive and activated CD4^+^ T cells (two group example)

This section highlights the use of BASiCS to perform differential testing (mean and variability) between cells of two condtions. 
For convenience, we will compare the naive CD4^+^ T cells, which were analysed in the previous section to activated CD4^+^ T cells of the same dataset [@Martinez-jimnenez2017].
Naive CD4^+^ T cells were activated for 3 hours using plate-bound CD3e and CD28 antibodies.
T cell activation is linked to strong transcriptional shifts and the up-regulation of lineage specific marker genes, such as Tbx21 and Gata1 *ref, ref*.
To generate this data, the authors did not add cytokines, which are needed for T cell differentiations *ref*, meaning that any heterogeneity in the activated cell population does not arise from cells residing in different lineage-specific differentiation states.
Prior to differential testing, and as explained above, we need to generate a `SingleCellExperiment` object that is compatible for processing using `BASiCS`.

### Creating the BASiCS Data objects

We have performed quality control on the naive and activated CD4^+^ T cells above *link to filtering section*. 
Therefore, we can directly select the activated CD4^+^ T cells from the `sce.naive_active` object.

```{r SCE-active}
ind_active <- sce.naive_active$Stimulus == "Active"
sce.active <- sce.naive_active[, ind_active]
```

Similar to the procedure described above *link to naive section*, we will use the `newBASiCS_Data` function to re-generate the `SingleCellExperiment` object for the use with BASiCS.

```{r Data-active}
# Select the ERCC spike-ins of the dataset
ind_spike <- rownames(sce.active)[isSpike(sce.active)]
SpikeInput <- ERCC.count[ind_spike, ]

# Generate the SingleCellExperiment object
Data.active <- newBASiCS_Data(Counts = counts(sce.active), 
                              Tech = isSpike(sce.active), 
                              SpikeInfo = SpikeInput, 
                              BatchInfo = sce.active$Individuals)
```

### Running the MCMC

BASiCS takes this `SingleCellExperiment` object and runs the MCMC sampler over 40,000 iterations. 

```{r MCMC-active, echo=FALSE, eval=FALSE}
MCMC.active <- BASiCS_MCMC(Data = Data.active, 
                           N = 1000, 
                           Thin = 10, 
                           Burn = 500, 
                           Regression = TRUE, 
                           WithSpikes = TRUE)
```

This sampler runs for *XYZ minutes* on a 1.4 GHz Intel Core i5 procesor with 4GB RAM and produces a `BASiCS_Chain` data object.
For convenience, this MCMC chain can be again obtained online at [https://jmlab-gitlab.cruk.cam.ac.uk/publications/BASiCSWorkflow2018](https://jmlab-gitlab.cruk.cam.ac.uk/publications/BASiCSWorkflow2018).

```{r download-chain-naive}
MCMC.active <- readRDS(file = url("https://jmlab-gitlab.cruk.cam.ac.uk/publications/BASiCSWorkflow2018/raw/master/MCMCs/MCMC_active.rds"))
```

### Quality checks

Similar to the `BASiCS_Chain` quality checks described above, we will again profile the convergence of the chain and if the regression captures the mean-variability dependency across the full range of data points.

```{r convergence-active}
# Convergence of mean expression parameters
plot(mcmc(displayChainBASiCS(MCMC.active, Param = "mu")[, 1]))
plot(mcmc(displayChainBASiCS(MCMC.active, Param = "mu")[, 1000]))
plot(mcmc(displayChainBASiCS(MCMC.active, Param = "mu")[, 10000]))

# Convergence of over-dispersion parameters
plot(mcmc(displayChainBASiCS(MCMC.active, Param = "delta")[, 1]))
plot(mcmc(displayChainBASiCS(MCMC.active, Param = "delta")[, 1000]))
plot(mcmc(displayChainBASiCS(MCMC.active, Param = "delta")[, 10000]))

# Convergence of residual over-dispersion parameters
plot(mcmc(displayChainBASiCS(MCMC.active, Param = "epsilon")[, 1]))
plot(mcmc(displayChainBASiCS(MCMC.active, Param = "epsilon")[, 1000]))
plot(mcmc(displayChainBASiCS(MCMC.active, Param = "epsilon")[, 10000]))

# Convergence of mRNA capture efficiency parameters
plot(mcmc(displayChainBASiCS(MCMC.active, Param = "s")[, 1]))
plot(mcmc(displayChainBASiCS(MCMC.active, Param = "s")[, 10]))
plot(mcmc(displayChainBASiCS(MCMC.active, Param = "s")[, 50]))

# Convergence of mRNA content parameters
plot(mcmc(displayChainBASiCS(MCMC.active, Param = "phi")[, 1]))
plot(mcmc(displayChainBASiCS(MCMC.active, Param = "phi")[, 10]))
plot(mcmc(displayChainBASiCS(MCMC.active, Param = "phi")[, 50]))

# Convergence of batch-specific global noise parameters
plot(mcmc(displayChainBASiCS(MCMC.active, Param = "theta")[, 1]))
plot(mcmc(displayChainBASiCS(MCMC.active, Param = "theta")[, 2]))
```

Again, we can assess the quality of the samples generated by assessing 
the effective sample size of the parameters. 

*why does it fail for all parameters?*
*examine which genes have low ESS, exclude from further analysis*

```{r convergence-ess}
BASiCS_diagHist(MCMC.active, Param = "mu")
BASiCS_diagHist(MCMC.active, Param = "delta")

BASiCS_diagPlot(MCMC.active, Param = "mu")
BASiCS_diagPlot(MCMC.active, Param = "delta")

```


To highlight the regression trend, we can use the `BASiCS_showFit` function.

```{r active-fit}
BASiCS_showFit(MCMC.active)
```

The MCMC sampler converged and the regression captured the full range of data points similar to the regression done on naive CD4^+^ T cells.
We can therefore move on to perform differential testing between naive and activated CD4^+^ T cells.

## Differential testing

### Differential mean expression

Standard DE test, highlight genes associated to immune activation and perform GO analysis.

### Differential over-dispersion

DV on logFC = 0 to highlight global changes in variability. 

### Differential residual over-dispersion

First, gene-wise DV, GO analysis.

Second, DE and DV analysis, GO analysis and:

*Check if cytokines are variably up-regulated* This is in line with Sarah Teichmann's recent paper.

# Differential testing using differentiating cells (two group, droplet-based example)

With the development of droplet-based scRNA-Seq [@Klein2015, @Makosco2015] lead to a strong increase in the number of cells that can be profiled per experiment. 
With this, large-scale scRNA-Seq datasets have been generated to study development across multiple time-points and capturing musltiple tissues [@Ibarra-Soria2018, @Kernfeld2018]. 
Here we describe the computational analysis of changes in mean expression and transcriptional variability when data is sparse and technical spike-in genes are missing. 
For this, we compare cells of the presomitic mesoderm and somitic mesoderm using droplet-based scRNA-Seq data [@Ibarra-Soria2018].

## Obtaining the data

The full dataset is stored under the accession number E-MTAB-6153 on ArrayExpress and can be obtained via:

```{r load-droplet-data}
library("data.table")
if(!file.exists("rawCounts.zip")){
  download.file("https://www.ebi.ac.uk/arrayexpress/files/E-MTAB-6153/E-MTAB-6153.processed.2.zip", 
                destfile = "rawCounts.zip")
  unzip(zipfile = "rawCounts.zip", exdir = "./")
}
rawCounts <- as.matrix(fread("rawCounts.tsv", sep = "\t", header = FALSE, 
                   data.table = FALSE))

# Genenames are stored in first column
rownames(rawCounts) <- rawCounts[, 1]
rawCounts <- rawCounts[, -1]
```

*Of note:* The file is 65 mb in size while the unzipped, raw counts measure 873 mb in size.

The cluster labels of the original publication ca be obtained via:

```{r cluster-labels-droplet}
if(!file.exists("cluster_labels.zip")){
  download.file("https://www.ebi.ac.uk/arrayexpress/files/E-MTAB-6153/E-MTAB-6153.processed.3.zip", 
                destfile = "cluster_labels.zip")
  unzip(zipfile = "cluster_labels.zip", exdir = "./")
}

cluster_labels <- read.table("cellAnnotation.tsv", sep = "\t", header = TRUE, stringsAsFactors = FALSE)
```

## Generating SingleCellExperiment object

For pre-processing and visualization purposes, we load the data into a SingleCellExperiment object.
The metadata will be stored in the `colData` slot.

```{r droplet-sce}
droplet.sce <- SingleCellExperiment(assays = list(counts = as(rawCounts, "dgCMatrix")))
rm(rawCounts)
colData(droplet.sce) <- DataFrame(cluster_labels, subCellType = sub("_.*", "", cluster_labels$cell))
```

## Select populations of interest and quality control

We select the somitic and pre-somitic mesoderm cells to perform differential testing. 
Prior to running the MCMC, we want to control for outlying cells and heterogeneous substructure in both cell populations. 

```{r droplet-cell-selection}
ind_som <- <- which(colData(droplet.sce)$cellType == "presomiticMesoderm" | 
        colData(droplet.sce)$cellType == "somiticMesoderm")
droplet.sce <- droplet.sce[, ind_som]
```

For further processing steps, we remove lowly expressed genes.

```{r}
ind_expressed <- Matrix::rowMeans(counts(droplet.sce)) > 0.1
droplet.sce <- droplet.sce[ind_expressed, ]
```

To visualize possible sub-structure in the data, we normalize both cell populations using the `scran` package.

```{r}
droplet.sce <- computeSumFactors(droplet.sce, 
                                 clusters=colData(droplet.sce)$subCellType)
droplet.sce <- normalize(droplet.sce)
```

Next, we compute a PCA using the `scater` package. 

```{r}
droplet.sce <- runPCA(droplet.sce)
```

We can now visualize the different factors stored in the `colData` slot.

```{r}
# Cell types identified by clustering
plotReducedDim(droplet.sce, use_dimred = "PCA", colour_by = "subCellType", alpha = 1) + 
  scale_fill_manual(values = c("coral4", "steelblue", "limegreen"))
```

The first PC separates the two different cell types while the second PC captures outlying cells.
We will remove these outliers and the intermediate cell population from down-stream analysis.

```{r}
ind_retain <- reducedDims(droplet.sce)$PCA[, 2] > -5 &
    colData(droplet.sce)$subCellType != "presomiticMesoderm.b"
droplet.sce <- droplet.sce[, ind_retain]
```

We now collected the cells that we want to process using BASiCS. 
For this, we will generate the BASiCS data objects.

## Generating BASiCS data objects

Since droplet-based scRNA-Seq data are generated without including technical spike-in genes, BASiCS uses measurement error models to quantify technical variation through replication [@Carrol1998].
Here, it is crucial to provide batch information to the BASiCS model.
In the case of the somitic and pre-somoitic mesoderm cells, embryos of two mice have been used to generate the data. 
Cells isolated from the first embryo were split into two batches and processed independently.
To capture cell-type extrinsic, biological variation between the two mice, we pool cells from the two batches of the first animal and only considere cells from mouse 1 and mouse 2 as replicates.

```{r BASiCS-droplet-data}
# Presomitic mesoderm
ind_presom <-colData(droplet.sce)$cellType == "presomiticMesoderm"
cur_counts <- droplet.sce[, ind_presom]
cur_batch <- round(colData(cur_counts)$sample, digits = 0)

PSM.Data <- newBASiCS_Data(Counts = as.matrix(counts(cur_counts)),
                           Tech = rep(FALSE, nrow(droplet.sce)),
                           SpikeInfo = NULL,
                           BatchInfo = cur_batch)

# Somitic mesoderm
ind_som <- colData(droplet.sce)$cellType == "somiticMesoderm"
cur_counts <- droplet.sce[, ind_som]
cur_batch <- round(colData(cur_counts)$sample, digits = 0)

SM.Data <- newBASiCS_Data(Counts = as.matrix(counts(cur_counts)),
                           Tech = rep(FALSE, nrow(droplet.sce)),
                           SpikeInfo = NULL,
                           BatchInfo = cur_batch)
```

## Running the MCMC

We next estimate model parameters by running the MCMC cell-type specifically. 
Due to the high cell number (1150 for the pre-somitic mesoderm and 739 for the somitic mesoderm), we set the number of iterations to 20000. 
In this case, we used the regression BASiCS model to additionally estimate residual over-dispersion parameters.

```{r, eval = FALSE}
# Presomitic mesoderm cells
PSM.MCMC <- BASiCS_MCMC(PSM.Data, N = 20000, Thin = 10, Burn = 10000, Regression = TRUE)

# Somitic mesoderm cells
SM.MCMC <- BASiCS_MCMC(SM.Data, N = 20000, Thin = 10, Burn = 10000, Regression = TRUE)
```

Running these MCMC will take around 8-12 hours on a standard PC (2.6 GHz i5, 8 GB RAM, using 1 core). Here, we provide these chains to download from:

```{r droplet-chain-download}
PSM.MCMC <- readRDS(file = url("https://jmlab-gitlab.cruk.cam.ac.uk/publications/BASiCSWorkflow2018/raw/master/MCMCs/PSM_MCMC.rds"))
SM.MCMC <- readRDS(file = url("https://jmlab-gitlab.cruk.cam.ac.uk/publications/BASiCSWorkflow2018/raw/master/MCMCs/SM_MCMC.rds"))
```

## Validating the model fit

Next, we visualize the results of the MCMC sampler by visualizing the different chains and by plotting the regression trend.
To assess whether the chains converged, we will visualize trace plots for some of the parameters. 
The `mcmc` function of the `coda` package is suited to generate trace plots for each chain. 

```{r droplet-chain-convergence}
plot(mcmc(displayChainBASiCS(PSM.MCMC, Param = "mu")[, 120]), main = "mu[120]")
plot(mcmc(displayChainBASiCS(PSM.MCMC, Param = "delta")[, 10]), main = "delta[10]")
plot(mcmc(displayChainBASiCS(PSM.MCMC, Param = "epsilon")[, 20]), main = "epsilon[20]")
plot(mcmc(displayChainBASiCS(PSM.MCMC, Param = "s")[, 90]), main = "s[90]")
plot(mcmc(displayChainBASiCS(PSM.MCMC, Param = "nu")[, 100]), main = "nu[100]")
plot(mcmc(displayChainBASiCS(PSM.MCMC, Param = "beta")[, 2]), main = "beta[2]")
plot(mcmc(displayChainBASiCS(PSM.MCMC, Param = "sigma2")), main = "sigma2")

plot(mcmc(displayChainBASiCS(SM.MCMC, Param = "mu")[, 120]), main = "mu[120]")
plot(mcmc(displayChainBASiCS(SM.MCMC, Param = "delta")[, 10]), main = "delta[10]")
plot(mcmc(displayChainBASiCS(SM.MCMC, Param = "epsilon")[, 20]), main = "epsilon[20]")
plot(mcmc(displayChainBASiCS(SM.MCMC, Param = "s")[, 90]), main = "s[90]")
plot(mcmc(displayChainBASiCS(SM.MCMC, Param = "nu")[, 100]), main = "nu[100]")
plot(mcmc(displayChainBASiCS(SM.MCMC, Param = "beta")[, 2]), main = "beta[2]")
plot(mcmc(displayChainBASiCS(SM.MCMC, Param = "sigma2")), main = "sigma2")
```

We observe that the chains for all chosen paramteres converged. 
Furthermore, to validate that the model fitted the mean-variability trend correctly, we plot posterior estimates for over-dispersion paramters $\delta_i$ against posterior estimates of mean expression parameters $\mu_i$.
For this, the `BASiCS_showFit` function can be used.

```{r droplet-regression-trend}
BASiCS_showFit(PSM.MCMC)
BASiCS_showFit(SM.MCMC)
```

Both trends display similar behaviour which allows us to compare residual over-dispersion estimates.

## Differential testing 

Next, we test for changes in mean expression and expression variability between the somitic and pre-somitic mesoderm.
First, we are interested in assessing global changes in expression variability between the two conditions.
For this, over-dispersion paramters $\delta_i$ for genes that are similarly expressed in both conditions are compared.

```{r}
Droplet.Test.logFC0 <- BASiCS_TestDE(PSM.MCMC, SM.MCMC, EpsilonM = 0, 
                                     GroupLabel1 = "PSM", GroupLabel2 = "SM")
for.plot <- Droplet.Test.logFC0$TableDisp[Droplet.Test.logFC0$TableDisp$ResultDiffDisp != "ExcludedFromTesting",
                                          c("Disp1", "Disp2")]
for.plot <- melt(for.plot)
ggplot(for.plot) + geom_boxplot(aes(variable, log(value))) + 
  scale_x_discrete(labels = c("PSM", "SM")) + theme_minimal(base_size = 15) + 
  ylab("log(delta)") + xlab("")
```

### Global changes in variability

With this analysis, we do not detect global changes in expression variability.
We next profile changes in mean expression and expression variability on a gene-specific level.
For this, we use a log~2~ fold change threshold of 1 for mean expression testing and the default threshold of $\psi_0\approx0.41$ for differential variability testing.

```{r droplet-gene-specific-testing}
Droplet.Test <- BASiCS_TestDE(PSM.MCMC, SM.MCMC, EpsilonM = 1, 
                              GroupLabel1 = "PSM", GroupLabel2 = "SM", 
                              Plot = FALSE, PlotOffset = FALSE)

# Differential expression
ggplot(Droplet.Test$TableMean) + 
  geom_point(aes(log(MeanOverall), MeanLog2FC, colour = ResultDiffMean)) +
  theme_minimal(base_size = 15) + 
  scale_colour_manual(name = "Differential expression", values = c("grey80", "#2166ac", "#b2182b")) +
  ylab(expression(mu[PSM]/mu[SM])) + xlab(expression(log(mu))) 

# Differential variability
ggplot(Droplet.Test$TableResDisp) + 
  geom_point(aes(log(MeanOverall), ResDispDistance, colour = ResultDiffResDisp)) +
  theme_minimal(base_size = 15) + 
  scale_colour_manual(name = "Differential variability", values = c("black", "grey80", "#542788", "#b35806")) +
  ylab(expression(epsilon[PSM]-epsilon[SM])) + xlab(expression(log(mu))) 
```

### Differential mean expression

We can now list the genes that were detected as differenitally expressed and differentially variable ordered by their difference in mean expression/variability.
We first focus on genes that are differentially expressed between the two cell types.

```{r gene-lists-mean}
# Highly expressed in somitic mesoderm
ind_sm <- Droplet.Test$TableMean$ResultDiffMean == "SM+"
SM.mean <- Droplet.Test$TableMean[ind_sm, ]
SM.mean <- SM.mean[order(SM.mean$MeanLog2FC, decreasing = FALSE), ]
SM.mean$Symbol <- genenames[SM.mean$GeneName, 2]

# Highly expressed in pre-somitic mesoderm
ind_psm <- Droplet.Test$TableMean$ResultDiffMean == "PSM+"
PSM.mean <- Droplet.Test$TableMean[ind_psm, ]
PSM.mean <- PSM.mean[order(PSM.mean$MeanLog2FC, decreasing = TRUE), ]
PSM.mean$Symbol <- genenames[PSM.mean$GeneName, 2]
```

We can next perform GO analysis on up- or down-regulated genes. 
First, we will perform GO analysis on somitic mesoderm specific genes.

```{r GO-analysis-mean-SM}
# Collect significan genes as 1 and all other as 0
SM.genes <- as.integer(Droplet.Test$TableMean$ResultDiffMean == "SM+")
names(SM.genes) <- Droplet.Test$TableMean$GeneName

# Build a Null distribution by correcting the gene length bias
pwf <- nullp(SM.genes, "mm10", "ensGene", bias.data = genelength[names(SM.genes)])
GO.wall <- goseq(pwf, "mm10", "ensGene")
ind_signif <- p.adjust(GO.wall$over_represented_pvalue, method = "fdr") < 0.01
SM.GO <- DataFrame(GO.wall[ind_signif, ])

# Add genenames to the GO categories
all_genes <- vector(length = nrow(SM.GO))
for(j in 1:nrow(SM.GO)){
  allegs <- get(SM.GO$category[j], org.Mm.egGO2ALLEGS)
  genes <- unique(unlist(mget(allegs, org.Mm.egENSEMBL)))
  genes <- as.character(intersect(genes, SM.mean$GeneName))
  all_genes[j] <- paste(genes, collapse = ", ")
}
SM.GO$Genes <- all_genes
```

Now, we perform GO analysis on pre-somitic mesoderm specific genes

```{r GO-analysis-mean-PSM}
# Collect significan genes as 1 and all other as 0
PSM.genes <- as.integer(Droplet.Test$TableMean$ResultDiffMean == "PSM+")
names(PSM.genes) <- Droplet.Test$TableMean$GeneName

# Build a Null distribution by correcting the gene length bias
pwf <- nullp(PSM.genes, "mm10", "ensGene", bias.data = genelength[names(PSM.genes)])
GO.wall <- goseq(pwf, "mm10", "ensGene")
ind_signif <- p.adjust(GO.wall$over_represented_pvalue, method = "fdr") < 0.01
PSM.GO <- DataFrame(GO.wall[ind_signif, ])

# Add genenames to the GO categories
all_genes <- vector(length = nrow(PSM.GO))
for(j in 1:nrow(PSM.GO)){
  allegs = get(PSM.GO$category[j], org.Mm.egGO2ALLEGS)
  genes = unique(unlist(mget(allegs, org.Mm.egENSEMBL)))
  genes = as.character(intersect(genes, PSM.mean$GeneName))
  all_genes[j] <- paste(genes, collapse = ", ")
}
PSM.GO$Genes <- all_genes
```

To visualize the expression of individual genes, we can use the `scater` package.

```{r}
# Expression of Fgf8 in both conditions
ind_fgf <- genenames$external_gene_name == "Fgf8"
plotExpression(droplet.sce, features = genenames[ind_fgf, 1], 
               x = "cellType", colour_by = "cellType")
plotReducedDim(droplet.sce, use_dimred = "PCA", 
               colour_by = genenames[ind_fgf, 1])
```

Visualize one category in form of heatmap.

```{r, fig.height = 7, fig.width = 5}
genes <- unlist(strsplit(PSM.GO[1, "Genes"], ", "))
for.heatmap <- logcounts(droplet.sce)[genes, ]
colnames(for.heatmap) <- colData(droplet.sce)$cell

# Order cells by cell type
for.heatmap <- for.heatmap[, order(colnames(for.heatmap))]

# Order rows by log2FC
heatmap_ind <- match(rownames(for.heatmap), PSM.mean$GeneName)
heatmap_order <- order(PSM.mean[heatmap_ind, "MeanLog2FC"], decreasing = TRUE)
for.heatmap <- for.heatmap[heatmap_order, ]

pheatmap(for.heatmap, cluster_cols = FALSE, show_colnames = FALSE, cluster_rows = FALSE,
         color = colorRampPalette(c("#053061", "#4393c3", "white", "#d6604d", "#67001f"))(100), 
         labels_row = genenames[rownames(for.heatmap), 2],
         cellheight = 8, fontsize = 7, annotation_col = data.frame(row.names = colnames(for.heatmap),
         cellType = sub("_.*", "", colnames(for.heatmap))), scale = "row")
```


### Differential variability testing

Next, we are interested in genes that change in variability between the two cell types.
To help interpretion of the result, we will split the genes into four categories.
These include:
* More variable in SM, highly expressed in SM
* More variable in SM, lowly expressed in SM
* More variable in PSM, highly expressed in PSM
* More variable in PSM, lowly expressed in SM

```{r}
gene.groups <- data.frame(Genename = Droplet.Test$TableResDisp$GeneName,
                          Symbol = genenames[Droplet.Test$TableResDisp$GeneName, 2],
                          MeanLog2FC = Droplet.Test$TableMean$MeanLog2FC,
                          ResDispDistance = Droplet.Test$TableResDisp$ResDispDistance,
                          Regulation = paste(Droplet.Test$TableMean$ResultDiffMean, 
                                             Droplet.Test$TableResDisp$ResultDiffResDisp,
                                             sep = "_"))

ind_reg <- gene.groups$Regulation %in% c("SM+_SM+", "SM+_PSM+", "PSM+_PSM+", "PSM+_SM+")
gene.groups <- gene.groups[ind_reg, ]

gene.groups[gene.groups$Regulation == "SM+_SM+", ]
```

We can visualize individual genes using `scater`.

```{r violin-plots}
# Expression of Meox2 in both conditions
ind_meox <- genenames$external_gene_name == "Meox2"
plotExpression(droplet.sce, features = genenames[ind_meox, 1], 
               x = "cellType", colour_by = "cellType") + 
  scale_fill_manual(values = c("coral4", "limegreen"))
plotReducedDim(droplet.sce, use_dimred = "PCA", 
               colour_by = genenames[ind_meox, 1], alpha = 1)
```

# Discussion 
This section is required if the paper does not include novel data or analyses.  It allows authors to briefly summarize the key points from the article.

# Session Info

```{r, session-info}
devtools::session_info()
```

# Software version

**Versions of all main Bioconductor packages**

# Data availability

**Links to Grun data and Ximenas data**
**Links to MCMC chains**


# Software availability

**Software: All software used in this workflow is available as part of Bioconductor X.Y**
**The source code of this workflow is available from: YYY**
**Link to Github release version, source code**
**License: ask Aaron**

This section will be generated by the Editorial Office before publication. Authors are asked to provide some initial information to assist the Editorial Office, as detailed below.

1. URL link to where the software can be downloaded from or used by a non-coder (AUTHOR TO PROVIDE; optional)
2. URL link to the author's version control system repository containing the source code (AUTHOR TO PROVIDE; required)
3. Link to source code as at time of publication (*F1000Research* TO GENERATE)
4. Link to archived source code as at time of publication (*F1000Research* TO GENERATE)
5. Software license (AUTHOR TO PROVIDE; required)


# Author information
In order to give appropriate credit to each author of an article, the individual contributions of each author to the manuscript should be detailed in this section. We recommend using author initials and then stating briefly how they contributed.

# Competing interests
All financial, personal, or professional competing interests for any of the authors that could be construed to unduly influence the content of the article must be disclosed and will be displayed alongside the article. If there are no relevant competing interests to declare, please add the following: 'No competing interests were disclosed'.

# Grant information
Please state who funded the work discussed in this article, whether it is your employer, a grant funder etc. Please do not list funding that you have that is not relevant to this specific piece of research. For each funder, please state the funder’s name, the grant number where applicable, and the individual to whom the grant was assigned. If your work was not funded by any grants, please include the line: 'The author(s) declared that no grants were involved in supporting this work.'

# Acknowledgments
This section should acknowledge anyone who contributed to the research or the article but who does not qualify as an author based on the criteria provided earlier (e.g. someone or an organization that provided writing assistance). Please state how they contributed; authors should obtain permission to acknowledge from all those mentioned in the Acknowledgments section.

Please do not list grant funding in this section.
