---
title: "BASiCS workflow: a step-by-step analysis of expression variability using single cell RNA sequencing data"
author: 
  - name: Nils Eling
    affiliation: 
    - &EBI European Molecular Biology Laboratory, European Bioinformatics 
      Institute, Wellcome Trust Genome Campus, Hinxton, Cambridge CB10 1SD, UK
    - &CRUK Cancer Research UK Cambridge Institute, University of Cambridge, 
      Li Ka Shing Centre, Cambridge, CB2 0RE, UK
    email: eling@ebi.ac.uk
  - name: Alan O'Callaghan
    affiliation: 
    - &MRC MRC Human Genetics Unit, Institute of Genetics \& Molecular Medicine, 
      University of Edinburgh, Western General Hospital, Crewe Road, Edinburgh, 
      EH4 2XU, UK
  - name: John C. Marioni
    affiliation: 
    - *EBI
    - *CRUK
  - name: Catalina A. Vallejos
    affiliation: 
    - *MRC 
    - The Alan Turing Institute, British Library, 96 Euston Road, London, 
      NW1 2DB, UK
    email: catalina.vallejos@igmm.ed.ac.uk
abstract: |
  Cell-to-cell gene expression variability is an inherent feature of complex 
  biological systems, such as immunity and development. Single-cell RNA 
  sequencing is a powerful tool to quantify this heterogeneity, but it is prone 
  to strong technical noise. In this article, we describe a step-by-step 
  computational workflow which uses the BASiCS Bioconductor package to robustly 
  quantify expression variability within and between known groups of cells (such 
  as experimental conditions or cell types). BASiCS uses an integrated framework 
  for data normalisation, technical noise quantification and downstream 
  analyses, whilst propagating statistical uncertainty across these steps. 
  Within a single seemingly homogeneous cell population, BASiCS can identify 
  highly variable genes that exhibit strong heterogeneity as well as lowly 
  variable genes with stable expression. BASiCS also uses a probabilistic 
  decision rule to identify changes in expression variability between cell 
  populations, whilst avoiding confounding effects related to differences in 
  technical noise or in overall abundance. Using two publicly available 
  datasets, we guide users through a complete pipeline which includes 
  preliminary steps for quality control as well as data exploration 
  using the scater and scran Bioconductor packages. Data for the first case 
  study was generated using the Fluidigm\@ C1 system, in which extrinsic 
  spike-in RNA molecules were added as a control. The second dataset was 
  generated using a droplet-based system, for which spike-in RNA is not 
  available. This analysis provides an example, in which differential 
  variability testing reveals insights regarding a possible early cell fate 
  commitment process. The workflow is accompanied by a Docker image that 
  ensures the reproducibility of our results. 
keywords: Single-cell RNA sequencing, expression variability, 
  transcriptional noise, differential expression testing
bibliography: Workflow.bib
urlcolor: Orange
output:
  BiocWorkflowTools::f1000_article: default
  BiocStyle::html_document: default
---


```{r setup_knitr, include = FALSE, cache = FALSE}
library("BiocStyle")
## Decide whether to display parts for BioC (TRUE) or F1000 (FALSE)
on.bioc <- FALSE
library("knitr")
library("ggplot2")
# Use fig.width = 7 for html and fig.width = 6 for pdf
fig.width <- ifelse(on.bioc, 7, 6)
knitr::opts_chunk$set(
  cache = TRUE, warning = FALSE, message = FALSE, error = FALSE,
  cache.path = "cache/", fig.path = "figure/", fig.width = fig.width
)
```


# Introduction

<!--- scRNA-seq and the different types of heterogeneity ---> 
<!--- Nils to revisit and add additional references if required --->
Single-cell RNA-sequencing (scRNA-seq) enables the study of genome-wide 
transcriptional heterogeneity in cell populations that remains otherwise 
undetected in bulk experiments [@Stegle2015; @Prakadan2017; @Patange2018]. 
Applications of scRNA-seq range from characterising cell types in immunity 
[@Lonnberg2017;  @Villani2017; @Zheng2017] and development [@Ibarra-Soria2018; 
@Wagner2018; @Pijuan-Sala2019] to dissecting the mechanisms for cell fate 
commitment [@Goolam2016; @Ohnishi2014]. 
Transcriptional heterogeneity within a population of cells can relate to 
different underlying structures. 
On the broadest level, this heterogeneity can relate to the presence of distinct 
expression profiles associated to cell subtypes or discrete states, which 
could be characterised through clustering [@Kiselev2019]. 
Alternatively, cell-to-cell expression heterogeneity can reflect gradual 
changes along processes that evolve over time and that can be characterised 
using pseudotime inference methods [@Saelens2019]. 
The focus of this article is on more subtle expression variability that can 
occur within a seemingly homogeneous cell population. This variability can be 
due to deterministic or stochastic events that regulate gene expression and has 
been reported to increase prior to cell phate decisions [@Mojtahedi2016] as well 
as throughout ageing [@Martinez-jimenez2017]. 

<!--- TBC intro to BASiCS ---> 
<!--- FINAL SENTENCES TO BE EDITED ---> 
This article complements existing workflows that use the Bioconductor package 
ecosystem to analyse scRNA-seq datasets [@Lun2016; @Kim2019], including the use 
of `r Biocpkg("scater")` and `r Biocpkg("scran")` to perform quality control 
steps and low-level preliminary analysis [@McCarthy2017; @Lun2016]. 
We present a step-by-step computational workflow to robustly quantify 
transcriptional variability using the `r Biocpkg("BASiCS")` package 
[@Vallejos2015; @Vallejos2016; @Eling2017]. 
`r Biocpkg("BASiCS")` implements a Bayesian hierarchical framework that 
simultaneously performs data normalisation (global scaling), technical noise quantification and selected downstream analyses whilst propagating 
statistical uncertainty across these steps. 
Within a population of cells, `r Biocpkg("BASiCS")` decomposes the total 
observed variability in gene expression measurements into technical and 
biological components. This enables the identification of highly variable genes
that [TBC]. Moreover, this variance decomposition enables detection of lowly
variable genes with stable expression [TBC - CITE GIGASCIENCE PAPER]. When two 
or more groups of cells are available (e.g. experimental conditions or
cell types), `r Biocpkg("BASiCS")` uses differential expression analysis to identify genes whose expression patterns change [@Vallejos2016]. 

<!--- TBC description of BASiCS downstream analysis, with focus on differential --->
<!--- add brief description for LVG/HVG 
<!--- Differential analyses ---> 
<!--- add reference to 11 challenges paper, flexible changes in expression ---> 
<!-- DE testing isn't always between (2) conditions (blocking, continuous, etc) -->
Since the era of RNA sequencing, methods for differential expression testing 
of transcript counts across conditions have been developed 
[@Anders2010; @Robinson2009]. 
Due to high technical variability and sparsity in scRNA-seq data, new 
approaches were developed for differential expression testing 
for scRNA-seq data [@Katayama2013; @Kharchenko2014; @Delmans2016]. 
In contrast to bulk samples, scRNA-seq measures variations in gene expression 
across a population of cells, and can therefore be used to test for changes in 
expression variability between two conditions. 
To do this, `BASiCS` compares the gene-specific over-dispersion parameters 
between two conditions. These parameters are independent of technical noise 
and can be used as proxy for biological variability [@Vallejos2016]. 
Similar to the mean-variability trend observed for normalised scRNA-seq data 
[@Brennecke2013], the estimates for over-dispersion parameters decrease with 
mean expression [@Vallejos2016].
To correct for this, BASiCS has been extended to model the mean-variability 
relationship and capture residual over-dispersion estimates that show no 
association to mean expression. 
Therefore, this extension allows to test changes in mean expression in parallel 
to changes in variability [@Eling2018]. 

<!--- TBC Outline - wider use of bioc libraries + case studies ---> 
Two case studies exemplify the use of `BASiCS` for non-UMI and UMI 
scRNA-seq data. In the first case, `BASiCS` can be used to detect highly and 
lowly variable genes and to obtain robust, gene-specific estimates to assess
biological variability in naive CD4^+^ T cells 
[@Martinez-jimenez2017]; for a similar workflow see [@Kim2019].
Furthermore, we compare naive to activated CD4^+^ T cells to highlight the use 
of `BASiCS` to test for changes in mean expression and expression variability.
In the second case, we use droplet-based scRNA-seq data to detect more subtle 
transcriptional changes during embryonic somitogenesis [@Ibarra-Soria2018]

<!---
In particular, 
the `r Biocpkg("BASiCS")` Bioconductor package implements a Bayesian 
hierarchical framework that propagates statistical 
uncerstainty into down-stream analyses, and allows the decomposition of total 
variance into biological and technical components by incorporating spike-in 
reads [@Vallejos2015]. Furthermore, `BASiCS` has been extended to perform 
differential mean expression and differential variability testing 
[@Vallejos2016].

package estimates gene- and cell-specific model parameters that can be used to, 
for example, normalise raw scRNA-seq counts and to detect highly and lowly 
variable genes [@Vallejos2015BASiCS]. 
`BASiCS` is a hierarchical Bayesian framework that propagates statistical 
uncerstainty into down-stream analyses, and allows the decomposition of total 
variance into biological and technical components by incorporating spike-in 
reads [@Vallejos2015]. Furthermore, `BASiCS` has been extended to perform 
differential mean expression and differential variability testing 
[@Vallejos2016].
--->
\newpage

## Outline

This article is organised as follows:

1. [Transcriptional noise](#noise-in-scRNA-seq-datasets): [TBC - summary about transcriptional noise]

2. [Methods](#methods): We describe the main Bioconductor packages used in 
  this worflow and introduce the different settings implemented in the 
  `r Biocpkg("BASiCS")` Bioconductor package. 
  
3. [Reproducibility](#reproducibility): [DESCRIBE COMP REQUIREMENTS, DOCKER, 
ETC --- CREATE SECTION IN MANUSCRIPT!]

4. [C1 Fluidigm data](#Tcells): We present an end-to-end analysis workflow to 
  obtain, process, quality filter raw expression counts of CD4^+^ T cells and how to 
  perform analysis using `r Biocpkg("BASiCS")`. 
  This section is sub-divided into a [single group case](#Tcells-single), 
  where `BASiCS` is used to normalise data and to detect highly and lowly 
  variable genes, and a [two group case](#Tcells-two), for which we perform 
  differential mean expression and differential variability testing.

5. [10X Genomics data](#droplet-data): We highlight the use of `BASiCS` for 
  scRNA-seq data that do not contain technical spike-in transcript. 
  In this case, technical noise is estimated via experimental replication.
  Similar to the CD4^+^ T cells case, we perform differential mean expression 
  and differential variability testing to detect early cell fate decision events 
  in mammalian somitogenesis. 

```{r overview, out.width='50%', fig.cap = 'Computational workflow highlighting the use of BASiCS to analyse single groups or two groups of cells. HVG: highly variable genes; LVG: lowly variable genes.', echo=FALSE, fig.pos='h'}
knitr::include_graphics("figure/Overview.png")
```

## Noise in scRNA-seq datasets

<!--- why is it challenging to study transcriptional noise? ---> 
[ADD INTRO SENTENCE]
The stochastic component of this variability is referred to as transcriptional 
*noise* and can arise from intrinsic and extrinsic sources of variability 
[@Elowitz2002; @Eling2019]. 
Classically, extrinsic noise is defined as stochastic fluctuations in cellular 
components induced by cells residing in different dynamic states (e.g. cell 
size, cell cycle, metabolism, intra- and inter-cellular signalling) [@Zopf2013; @Iwamoto2016; @Kiviet2014]. 
In contrast, intrinsic noise arises from stochastic effects on biochemical 
processes such as transcription and translation [@Elowitz2002].
Intrinsic noise can be modulated by genetic and epigenetic modifications (such 
as mutations, histone modifications, CpG island length and nucleosome 
positioning) [@Eberwine2015; @Faure2017; @Morgan2018] and is usually measured 
at the level of individual genes [@Elowitz2002]. Cell-to-cell gene expression 
variability estimates derived from scRNA-seq data capture a combination of 
these effects, as well as deterministic regulatory mechanisms [@Eling2019]. 
These variability estimates can also be inflated by the technical noise that is 
typically observed in scRNA-seq assays [@Brennecke2013].

<!--- Experimental strategies to tackle technical noise --->
Different strategies can be incorporated into scRNA-seq protocols in order to 
control or attenuate technical noise. 
For example, external RNA spike-in molecules (such as the set introduced by the 
External RNA Controls Consortium, ERCC [@Rna2005]) can be added to each cell’s 
lysate in a (theoretically) known fixed quantity.
Spike-ins can be used to assist quality control steps [@McCarthy2017], data 
normalisation [@Vallejos2017] as well as to infer technical background noise [@Brennecke2013].
Another strategy is to tag individual cDNA molecules using unique molecular 
identifiers (UMIs) before PCR amplification [@Islam2014]. 
Reads that contain the same UMI can be collapsed into a single molecule count,
attenuating technical variability associated to cell-to-cell differences
in amplification and sequencing depth (these technical biases are not fully 
removed unless sequencing to saturation [@Vallejos2017]). 
However, despite the benefits associated to the use of spike-ins and UMIs, 
these are not available for all scRNA-seq protocols [@Haque2017]. 

# Methods {#methods}

In this workflow, we use a number of Bioconductor and CRAN packages for 
different parts of the analyses. Here, we will briefly highlight the main 
functionalities of these packages from a user's perspective.

The `r Biocpkg("SingleCellExperiment")` Bioconductor package offers an S4 
class container to store scRNA-seq count data and their associated gene- and 
cell-specific metadata. 
Throughout this workflow, we perform analyses using a `SingleCellExperiment` 
object that contains (at least) the raw expression counts, gene identifiers, 
batch information and cell identifiers.
The `SingleCellExperiment` package uses `r Biocpkg("SummarizedExperiment")`,
a container used in many Bioconductor packages to contain tabular biological 
data. The `SingleCellExperiment` function takes a list of assays taken
of the samples, usually including the raw expression counts, and the cell- and 
gene-specific metadata in the form of `data.frame`s.

The `r Biocpkg("scater")` Bioconductor package was developed to facilitate 
the handling of scRNA-seq data [@McCarthy2017].
Its main functions include the calculation of quality control (QC) metrics, 
the visualisation of such metrics and expression counts, and the normalisation 
of expression counts.
We will primarily use the `calculateQCMetrics` function to calculate cell- 
and gene-specific QC metrics, the `plotPCA` function to visualise QC 
metrics, metadata, and gene expression, and the `logNormCounts` function to 
normalise expression data.

The `r Biocpkg("scran")` Bioconductor package offers a variety of functions 
for low-level scRNA-seq data analysis [@Lun2016].
While it contains function for doublet detection, and estimation 
of cell cycle states, we will use it primarily for normalisation in conjunction
with the `scater` package [@Lun2016pooling], and for modelling the mean-variance 
trend across all genes.
The `trendVar` and `decomposeVar` functions will be used to fit a 
trend between the gene-specific variances and gene-specific mean expression,
before decomposing the overall variance into technical and biological 
components. Furthermore, we will use the `DM` function to calculate the distance
of gene-specific squared coefficients of variation (CV^2) to a rolling median 
along mean expression [@Kolodziejczyk2015cell].

The `r Biocpkg("BASiCS")` Bioconductor package contains an assembly of 
functions to estimate and analyse gene- and cell-specific model parameters 
[@Vallejos2015BASiCS; @Vallejos2016; @Eling2018].
`BASiCS` is build upon a hierarchical Baysian framework and as such samples 
posterior distribution for each model parameter.
In mathematical terms, the gene expression count $X_{ij}$ for gene $i$ in cell 
$j$ is modelled as:

$$
\begin{aligned}
X_{ij}|\mu_i,\nu_j&\sim{}\text{Poisson}(\nu_j\mu_i)\\
\nu_j|s_j,\theta&\sim{}\text{Gamma}(1/\theta,1/(s_j\theta))\\
\rho_{ij}|\delta_i&\sim{}\text{Gamma}(1/\delta_i,1/\delta_i)
\end{aligned}
$$

where $\mu_i$ explains the gene's mean expression, $\nu_j$ the technical effect 
characterised by the mRNA capture efficiency $s_j$ and the unexplained technical
noise parameter $\theta$. 
<!-- Here, $\phi_j$ is the cell-specifc size factor and  -->
Here, $\rho_{ij}$ the biological 
random effect fluctuating around the gene-specific over-dispersion 
hyper-parameter $\delta_i$.
It is important to note that, in further analyses, $\mu_i$ represents the
mean expression and $\delta_i$ the biological over-dispersion of each gene.

Due to a strong association between mean expression and biological 
over-dispersion, the model has been extended to correct for such confounding 
effect. To this end, the prior distribution for the over-dispersion parameters 
has been changed to:

$$
\delta_i | \mu_i \sim \text{log-t}_{\eta}\left( \text{f}(\mu_i), \sigma^2 \right).
$$

where $\text{f}(\mu_i)$ describes a smooth regression trend between the 
over-dispersion and the mean expression parameters.
This extension introduced the residual over-dispersion parameters 
$\epsilon_i=\delta_i-\text{f}(\mu_i)$ that do not scale with mean expression
[@Eling2018].

From a data analysis perspective, the `BASiCS_MCMC` function is the heart of 
the `BASiCS` package, and can be run in four different settings (see Table 1). 

: Four settings that can be used to run the `BASiCS_MCMC` function.

                        No regression         Regression           
----------------------- --------------------  -------------------
Using spike-in reads    `WithSpikes = TRUE`   `WithSpikes = TRUE`  
                        `Regression = FALSE`  `Regression = TRUE` 
No spike-ins available  `WithSpikes = FALSE`  `WithSpikes = FALSE` 
                        `Regression = FALSE`  `Regression = TRUE`
----------------------- --------------------  -------------------

If spike-in counts are availabe and should be used to estimate technical noise,
the parameter `WithSpikes` is set to `TRUE` (default).
If the regression between over-dispersion and mean expression should be 
performed, the `Regression` parameters is set to `TRUE` (default).
If the user decides to set `Regression = FALSE`, `BASiCS` will not estimate 
the regression trend, and will not supply the residual over-dispersion 
parameters $\epsilon_i$.

The `BASiCS_MCMC` function returns a `BASiCS_Chain` object, which can be used 
for further downstream analyses, many of which are detailed in this workflow.
These objects contain draws from Markov chain Monte Carlo (MCMC) samplers,
which are used to infer the posterior distribution over the model parameters
[@Smith1993].
Briefly, the posterior distribution quantifies how probable different parameter 
values are given the observed data. However, before assessing the posterior
distribution, we must first ensure that the MCMC sampler has converged to
its stationary distribution, and has sampled efficiently from this distribution
[@Cowles1996]. If these conditions are not met, then the estimated parameters
may be inaccurate. The `r CRANpkg("coda")` CRAN package contains a variety of 
functions to assess the convergence of a sampled MCMC chain. 
To use `coda` functions, the individual chains returned by `BASiCS` need to be 
transformed into a MCMC object that `coda` recognises using the `coda::mcmc` 
function. `BASiCS` also offers a number of functions to visualise and assess the 
convergence of MCMC chains. In particular, we will use 
`BASiCS_EffectiveSize` and `BASiCS_DiagPlot` to calculate and visualise the
effective sample size generated by the MCMC samplers.


The `r Biocpkg("goseq")` Bioconductor package offers functions to detect the 
enrichment of gene ontologies (GOs) among user-specified gene sets [@Young2010].
Furthermore, `goseq` corrects for gene length biases, which is useful for full 
length scRNA-seq data as highlighted in the first section. 
In this workflow, we will use `goseq` to detect GO enrichment among 
differentially expressed sets of genes.

For downstream analysis, such as GO enrichment analysis or the biological 
interpretation of individual genes, we need to (i) link each gene's ID to its 
symbol and (ii) calculate each gene's length.
For the first task, the `r Biocpkg("biomaRt")` Bioconductor package annotates a 
wide range of gene and gene product identifiers [@Durinck2005] by accessing the 
BioMart software suite ([http://www.biomart.org](http://www.biomart.org)).
We can use `biomaRt` to link the **Mus musculus** gene IDs and to their gene 
symbols (also referred to as 'gene name'): 


```{r libraries}
library("ggplot2")
library("viridis")
library("biomaRt")
library("EnsDb.Mmusculus.v79")
library("SingleCellExperiment")
library("scran")
library("scater")
library("BASiCS")
library("coda")
library("goseq")
library("org.Mm.eg.db")
library("data.table")
library("ComplexHeatmap")
library("ggpointdensity")

## Set theme for ggplot2 plots
theme_set(theme_bw(base_size = 15))
## Directories to store downloaded files and intermediate results
dir.create("rds", showWarnings = FALSE)
dir.create("downloads", showWarnings = FALSE)
```

```{r obtain-gene-symbols}
if (!file.exists("rds/genenames.rds")) {
  # Initialize mart and dataset
  ensembl <- useMart(
    biomart = "ensembl",
    dataset = "mmusculus_gene_ensembl"
  )

  # Select gene ID and gene name
  genenames <- getBM(
    attributes = c("ensembl_gene_id", "external_gene_name"),
    mart = ensembl
  )

  rownames(genenames) <- genenames$ensembl_gene_id
  saveRDS(genenames, "rds/genenames.rds")
} else {
  genenames <- readRDS("rds/genenames.rds")
}
```

For the second task, and to perform GO enrichment analysis, we further collected 
the gene length for each gene. This can be extracted from the
`r Biocpkg("EnsDb.Mmusculus.v79")` annotation package.
This resource offers gene annotations such as exon positions and promoters for 
the Ensembl database.

```{r gene-length}
if (!file.exists("rds/genelength.rds")) {
  # Build exon list
  exons_list <- exonsBy(EnsDb.Mmusculus.v79, by = "gene")

  # Calculate summed length of all exons
  genelength <- vapply(
    exons_list,
    function(x) {
      sum(width(reduce(x)))
    },
    numeric(1)
  )
  saveRDS(genelength, "rds/genelength.rds")  
}
genelength <- readRDS("rds/genelength.rds")

# Add gene length to gene names
genenames$gene_length <- genelength[genenames$ensembl_gene_id]
```

## Operation

The following R, Bioconductor and package version were used for this workflow:

**R version**: `r R.version.string`

**Bioconductor version**: `r BiocManager::version()`

**Packages**: BASiCS `r packageVersion("BASiCS")`, scran 
`r packageVersion("scran")`, scater `r packageVersion("scater")`, coda 
`r packageVersion("coda")`, goseq `r packageVersion("goseq")`    

For the full list of packages used, please see the [Session Info](#session-info).

# C1 Fluidigm data: Analysis of naive CD4^+^ T cells {#Tcells}

For the first case study, we will use scRNA-seq data of CD4^+^ T cells, which 
were processed using the C1 Single-Cell Auto Prep System (Fluidigm^®^) using 
10–17 $\mu{}m$ integrated fluidic circuits (IFCs). 
Martinez-Jimenez _et al._ profiled naive and activated CD4^+^ T cells from 
young and old animals across two mouse strains to test for changes in 
expression variability that occur during organismal ageing 
[@Martinez-jimenez2017]. They extracted naive or effector memory CD4^+^ T cells
from spleens of young or old animals and filtered using either 
magnetic-activated cell sorting (MACS) or fluorescence activated cell sorting 
(FACS) (labelled as MACS-purified Naive, FACS-purified Naive or FACS-purified 
Effector Memory).
For clarification, naive CD4^+^ T cells are also referred to as 'unstimulated' 
CD4^+^ T cells.

In addition to profiling naive CD4^+^ T cells, the authors stimulated half 
of the naive cells for 3 hours using _in vitro_ antibody stimulation (labelled 
as Active).
They processed naive as well as activated CD4^+^ T cells using the 
C1 Fluidigm^®^ system to capture and lyse cells, and to reverse transcribe 
and amplify mRNA prior to sequencing.
The authors isolated cells from B6 (C57BL/6J, _Mus musculus domesticus_) and
CAST (_Mus musculus castaneus_) animals to profile the evolutionary conservation
of transcriptional dynamics during ageing.
Additionally, the authors added external spike-in RNA to aid in quantifying
technical variability across all cells. They performed all experiments in
replicates (also referred to as batches) to control for batch effects.

We will begin the workflow with obtaining the data before quality control, 
running the BASiCS model, and performing further downstream analysis.


## Obtaining the data

The raw counts of the full dataset can be obtained from ArrayExpress under the 
accession number 
[E-MTAB-4888](https://www.ebi.ac.uk/arrayexpress/experiments/E-MTAB-4888/).
In this dataset, the column names contain the library identifier of the original 
experiment, while the row names of the matrix store gene names. 
The dataset contains reads mapped to ERCC spike-in genes [@Rna2005], which 
`BASiCS` uses to estimate and remove technical noise.

```{r naive-data}
if (!file.exists("downloads/raw_data.txt")) {
  # Download raw counts file
  website <- "https://www.ebi.ac.uk/"
  folder <- "arrayexpress/files/E-MTAB-4888/"
  file <- "E-MTAB-4888.processed.1.zip"
  destfile <- "downloads/raw_data.txt.zip"
  download.file(
    paste0(website, folder, file),
    destfile = destfile
  )
  unzip("downloads/raw_data.txt.zip", exdir = "downloads")
  file.remove("downloads/raw_data.txt.zip")
}

# Read in raw data
CD4_raw <- read.table("downloads/raw_data.txt", header = TRUE, sep = "\t")
CD4_raw <- as.matrix(CD4_raw)

# Show row and column names
head(colnames(CD4_raw))
head(rownames(CD4_raw))

# ERCC spike-in genes
head(rownames(CD4_raw)[grepl("ERCC", rownames(CD4_raw))])
```

To link the library identifiers to the experimental conditions, the authors 
provide a metadata file that can be accessed online under the same accession 
number.

```{r selecting-serum-cells}
download_file <- function(file, website, folder, destfile = file) {
  if (!file.exists(destfile)) {
    download.file(paste0(website, folder, file), destfile)
  }
}

if (!file.exists("downloads/metadata_file.txt")) {
  # Download raw counts file
  website <- "https://www.ebi.ac.uk/"
  folder <- "arrayexpress/files/E-MTAB-4888/"
  file <- "E-MTAB-4888.additional.1.zip"
  destfile <- "downloads/metadata.txt.zip"
  download.file(
    paste0(website, folder, file),
    destfile = destfile
  )
  unzip("downloads/metadata.txt.zip", exdir = "downloads")
  file.remove("downloads/metadata.txt.zip")
}
# Read in metadata file
CD4_metadata <- read.table("downloads/metadata_file.txt", header = TRUE, sep = "\t")

# Save library identifier as rownames
rownames(CD4_metadata) <- CD4_metadata$X

# Show metadata entries
head(CD4_metadata)
```

This metadata file contains the library identifiers (*X*), the strain 
information (*Strain*), the relative age of the animals (*Age*), the 
stimulation state of the cells (*Stimulus*), the batch information indicating 
the different mice used (*Individuals*), and the purification method used 
(*Celltype*). 


## Filtering the data

In the next step, we will first generate a `r Biocpkg("SingleCellExperiment")` 
(SCE) object that contains all cells and that stores cell- and gene-specific 
metadata.
This data class offers convenient ways to subset, set and retrieve cell- 
and gene-specific information. We will also store information on the spike-in
molecules using the `altExp` 
accessor. This allows us to store alternative experimental assays other
than endogenous genes --- in this case, technical (spike-in) genes.

```{r CD4-SCE-object}
# Load library
bio_counts <- CD4_raw[!grepl("ERCC", rownames(CD4_raw)), ]
spike_counts <- CD4_raw[grepl("ERCC", rownames(CD4_raw)), ]
# Generate the SingleCellExperiment object
sce_CD4_all <- SingleCellExperiment(
  assays = list(counts = as.matrix(bio_counts)),
  colData = CD4_metadata[colnames(CD4_raw), ]
)

altExp(sce_CD4_all, "spike-ins") <- SummarizedExperiment(
  assays = list(counts = spike_counts)
)
```

For further downstream analysis, we select naive and activated CD4^+^ T cells 
from young B6 animals that were obtained using the MACS-based cell selection.
It is crucial that proper quality control (QC) and filtering is performed 
before running BASiCS, and, in general, before performing any computational
analysis on biological data.

```{r naive-activated-CD4-SCE-object}
ind_select <- sce_CD4_all$Strain == "Mus musculus domesticus" &
  sce_CD4_all$Age == "Young" &
  sce_CD4_all$Celltype == "MACS-purified Naive"
sce_naive_active <- sce_CD4_all[, ind_select]
```

Prior to cell-specific quality control, we will remove all genes that are not
detected in at least 2 cells across both conditions.
Furthermore, we remove genes that are not expressed with an average count of 1 
across all cells.
These thresholds need to be set specifically for each dataset, and careful
gene-specific quality metrics need to be closely examined as suggested by the 
`r Biocpkg("SimpleSingleCell")` Bioconductor workflow [@Lun2016].

```{r gene-selection}
# Remove genes
ind_expressed <- rowSums(counts(sce_naive_active) > 0) > 1 &
  rowMeans(counts(sce_naive_active)) >= 1
sce_naive_active <- sce_naive_active[ind_expressed, ]
```

In the next step, we will use the `r Biocpkg("scran")` and 
`r Biocpkg("scater")` Bioconductor packages for initial normalisation and 
visualisation of quality metrics [@Lun2016,@McCarthy2017].
The normalisation at this point is needed to avoid biases in the visualisation 
due to differences in the mRNA content between cells.
In line with the normalisation strategy of BASiCS, we use the spike-in reads 
for normalisation.

```{r pre-normalisation}
# Pre-normalisation of data for visualisation purposes
sce_naive_active <- computeSpikeFactors(sce_naive_active, spikes = "spike-ins")
sce_naive_active <- logNormCounts(sce_naive_active)
```

The `Biocpkg("SimpleSingleCell")` Bioconductor workflow and
the `OSCA` online book each provide an extensive 
overview on important aspects of how to perform low-level analysis of scRNA-seq 
data, including quality control [@Lun2016;@Amezquita2019].
The `calculateQCMetrics` function of the `scater` package can be used to 
calculate a number of cell- and gene-specific quality metrics.
Furthermore, `scater` offers the `runPCA` function to perform principal 
component analysis (PCA) across all cells.

```{r scater-QC-metrics}
# Calculate quality metrics
sce_naive_active <- addPerCellQC(sce_naive_active, use_altexps = TRUE)
sce_naive_active <- addPerFeatureQC(sce_naive_active)

clean_colnames <- make.names(colnames(colData(sce_naive_active)))
colnames(colData(sce_naive_active)) <- clean_colnames

# Calculate PCA
sce_naive_active <- scater::runPCA(sce_naive_active)
```

For the CD4^+^ T cell dataset, the authors removed empty capture sites and 
sites containing multiple cells or debris, as observed by visual inspection. 
Furthermore, they removed cells which had fewer than 1,000,000 total reads, 
cells where less than 20% of reads mapped to endogenous genes, cells in which 
less than 1,250 or more than 3,000 genes were detected, and cells with more than 
10% or less than 0.5% reads mapping to mitochondrial genes 
[@Martinez-jimenez2017].

Since these data have been quality filtered in the original publication, we will 
only visualise the distribution of quality metrics across the cells.
The highlighted quality metrics can otherwise be used to identify low quality 
cells. These metrics include: number of endogeneous genes 
detected per cell, total number of reads per cell, the fraction of reads mapping
to spike-in and endogeneous genes.
The main aim is to identify broken or dying cells, cells for which a very
small quantity of mRNA was captured, and possibly empty wells.
For an extenive discussion on quality metrics for scRNA-seq data, see Ilicic 
*et al.* [@Ilicic2016].

The activation status and batch information for each individual cell of the 
selected dataset can be seen in Figure \@ref(fig:visualisation-stimulus-batch).

```{r visualisation-stimulus-batch,fig.height=2, fig.cap="Visualisation of the cell stimulus (left) and the batch information per cell (right). Cells from two animals were captured either in the naive or activated state.", fig.pos='h'}
# Visualise the conditions and batch structure
p_stimulus <- scater::plotPCA(sce_naive_active, colour_by = "Stimulus")
p_batch <- scater::plotPCA(sce_naive_active, colour_by = "Individuals")
multiplot(p_stimulus, p_batch, cols = 2)
```

The cells split into two conditions: naive and activated CD4^+^ T cells.
Furthermore, we detect neither obvious batch effects nor outlier cells.

<!-- What is a doublet? -->
In the next step, we will visualise selected cell-specific quality metrics 
overlayed on the principal components.
Figure \@ref(fig:no-genes_total-counts) highlights the number of endogeneous 
genes detected per cell and the total number of counts.
Both of these metrics can be used to detect empty wells or broken cells 
(low values) and possible doublets (high values).

```{r no-genes-total-counts, fig.height=2, fig.cap="Visualisation of the number of biological genes detected per cell (left) and the total number of reads per cell (right).", fig.pos='h'}
# Visualise number of endogeneous genes detected
p_total_features <- scater::plotPCA(
    sce_naive_active, 
    colour_by = "detected"
  ) +
  scale_fill_viridis_c(name = "Number of genes", trans = "log10")

# Visualise log10-transformed total number of counts
p_total_counts <- scater::plotPCA(
    sce_naive_active, 
    colour_by = "sum"
  ) +
  scale_fill_viridis_c(name = "Number of counts", trans = "log10")
multiplot(p_total_features, p_total_counts, cols = 2)
```

We detect a higher number of expressed genes and a higher total read count in
activated cells. Furthermore, cells within each group show a wide distribution
of these quality measures, without clear outlying cells.

A widely used quality visualisation is to plot the total number (or fraction) of 
spike-in counts versus the total number (or fraction) of endogeneous counts 
(Figure \@ref(fig:ERCC-endogeneous)).
In such a plot, low quality wells are characterised by a high fraction of 
spike-in counts and a low fraction of endogeneous counts.

```{r ERCC-endogeneous, fig.height=3, fig.width=3, fig.cap="The number of spike-in counts per cells is plotted against the number of endogeneous counts per cell. A dashed line indicates the minimum level of spike-in counts, below which cells are removed.", fig.pos='h'}
# Plot the fraction of reads mapping to spike-ins
# versus the number of reads mapping to endogeneous genes
ggplot(as.data.frame(colData(sce_naive_active))) +
  geom_point(aes(sum, altexps_spike.ins_sum)) +
  geom_vline(xintercept = 10^5.8, linetype = "dashed", colour = "grey60") +
  scale_x_log10() +
  scale_y_log10()
```

Since we are lacking the information of the total reads per cell (including the 
non-mapped and intronic reads), we can solely filter cells based on the total 
number of endogeneous counts (assuming equal numbers of spike-in molecules per 
well). Nevertheless, we remove two cells that showed unusually low number of 
reads mapping to endogeneous genes. We indicate the threshold used for filtering
on the plot using a dashed line.

```{r}
# Remove two cells that appear to be outliers
ind_retain <- log10(sce_naive_active$sum) > 5.8
sce_naive_active <- sce_naive_active[, ind_retain]
```

It is crucial that an in-depth quality control is performed to remove 
low-quality or outlying cells. Furthermore, these quality control steps can
help users to understand possible confounding effects that may influence
the interpretation of downstream analyses.


## Calculating the molecule count for spike-in genes

BASiCS requires the absolute molecule count of the spike-in transcripts that
were added to each well. To calculate the molecule count, we require the 
dilution and the concentration of the spike-in mix.
For this, a table of the spike-in concentrations can be downloaded from 
[https://www.thermofisher.com](https://www.thermofisher.com/order/catalog/product/4456740).
The file contains the concentrations of 2 ERCC spike-in mixes.

For the CD4^+^ T cell data, the authors added a 1:50,000 dilution of the ERCC 
spike-in mix 1 [@Martinez-jimenez2017].
We will first download the concentration information.

```{r spike-in_download}
# Read in the spike-in concentrations
website <- "https://assets.thermofisher.com/"
folder <- "TFS-Assets/LSG/manuals/"
file <- "cms_095046.txt"
download_file(file, website, folder, "downloads/spike_info.txt")

ERCC_conc <- read.table(
  "downloads/spike_info.txt",
  sep = "\t", header = TRUE
)
```

The concentration is given in units of $aM\mu{}l^{-1}$. 
We will first calculate the concentration in $M\mu{}l^{-1}$.

```{r}
# Moles per micro litre
ERCC_mmul <- ERCC_conc$concentration.in.Mix.1..attomoles.ul. * (10^(-18))
```

From this, we can calculate the molecule count per $\mu{}l$ using the fact that
1 mole is comprised of $6.02214076 \times 10^{23}$ molecules.

```{r}
# Molecule count per micro litre
ERCC_countmul <- ERCC_mmul * (6.02214076 * (10^23))
```

During the preparation of the reaction mix, the authors diluted this mix by a
factor of 1:50,000 [@Martinez-jimenez2017].
The actual molecule number of spike-ins can therefore be calculated per $\mu{}l$:

```{r}
ERCC_count <- ERCC_countmul / 50000
```

The volume per well in the IFC chip is $9nl$
[https://www.fluidigm.com/faq/ifc-9](https://www.fluidigm.com/faq/ifc-9).
We therfore need to calculate the number of molecules in $9nl$ reaction mix.

```{r}
ERCC_count_final <- ERCC_count * 0.009
```

Depending on the technology used to capture and process single cells, as well 
as the dilution of the spike-in mix, the absolute number of spike-ins per 
reaction can change. The absolute amount of spike-ins per reaction is only used 
to calibrate the scale of the capture efficiency normalisation parameter 
$\nu_j$. Since the true concentration of each spike-in molecule is known, 
BASiCS uses the observed counts of each molecule for each cell to estimate the 
capture efficiency for each cell, $\nu_j$. Differences in the 
global scale across all wells of the level of spike-ins molecules thus do not 
affect the cell-to-cell ratios of $\nu_j$.
BASiCS assumes that the quantity of spike-ins is consistent in each well in
each experiment. While the quantity used must remain constant between wells and
experiments, the scale does not affect the results, provided the spike-ins
are at a reasonable level. In particular, they should not be in such a low 
concentration that they are rarely detected, and they should not be at such
a high concentration that the majority of the sequencing reads map to the 
spike-in molecules.

We can now use the molecule count to prepare the BASiCS data object.
To incorporate the spike-in molecule counts within the 
`r Biocpkg("SingleCellExperiment")` object that BASiCS requires, the first 
column must contain the names associated to the spike-in genes. 
The second column must contain the input number of molecules for the spike-in 
genes (amount per reaction).


```{r spike-info}
# Prepare the data.frame
ERCC_count <- data.frame(
  row.names = ERCC_conc$ERCC.ID,
  Names = ERCC_conc$ERCC.ID,
  count = ERCC_count_final
)
```

## Single condition example: Naive CD4^+^ T cells {#Tcells-single}

To highlight the use of BASiCS to analyse cells in the single-condition case,
we select naive CD4^+^ T cells of young B6 animals.
Here, BASiCS can be used to identify highly- and lowly-variable genes and 
calculate interpretable gene- and cell-specific parameters.
Among others, these include gene-specific parameters for mean expression, 
over-dispersion (biological variability) and residual over-dispersion 
(biological variability after correcting for the mean expression effect).

### Preparing the BASiCS data object {#Tcells-filtering}

Many BASiCS functions use as input objects of the class 
`r Biocpkg("SingleCellExperiment")`.
The `newBASiCS_Data` function can be used to create the required 
`SingleCellExperiment` object based on the following information:

* Counts: a matrix of raw expression counts with dimensions $q$ times $n$, 
  where $q$ is the number of genes (technical + biological) and $n$ is the number 
  of cells. Gene names must be stored as row names of the counts matrix.

* Tech: a vector of `TRUE/FALSE` elements with length $q$. If `Tech[i] = FALSE` 
  the gene i is biological; otherwise the gene is spike-in. This vector must 
  be specified in the same order of genes as in the counts matrix.

* SpikeInfo: a `data.frame` with $q-q_0$ rows where $q_0$ is the number 
  of biological genes. The first column must contain the names associated to 
  the spike-in genes. The second column must contain the input number of 
  molecules for the spike-in genes (amount per cell).

* BatchInfo (optional argument): vector of length $n$ to indicate batch 
  structure in situations where cells have been processed using multiple 
  batches.

We will first select the naive cells from the `SingleCellExperiment` object 
that was generated above.

```{r SCE-naive}
ind_stimulated <- sce_naive_active$Stimulus == "Unstimulated"
sce_naive <- sce_naive_active[, ind_stimulated]
ind_expressed <- rowSums(counts(sce_naive) > 0) > 1 & 
  rowMeans(counts(sce_naive)) >= 1
sce_naive <- sce_naive[ind_expressed, ]
```

Next, we will use the `newBASiCS_Data` function to re-generate the 
`SingleCellExperiment` object for the use with BASiCS.

```{r Data-naive}
# Here is the first time that we use BASiCS

# Select the ERCC spike-ins of the dataset
counts <- counts(sce_naive)
spikes <- assay(altExp(sce_naive, "spike-ins"))
spikes_present <- rowSums(spikes) != 0
## Remove spike-ins that are not present from matrix and SCE object
spikes <- spikes[spikes_present, ]
altexp_present <- altExp(sce_naive, "spike-ins")[spikes_present, ]
altExp(sce_naive, "spike-ins") <- altexp_present
ind_spike <- c(rep(FALSE, nrow(counts)), rep(TRUE, nrow(spikes)))
spike_input <- ERCC_count[rownames(spikes), ]

# Generate the SingleCellExperiment object
data_naive <- newBASiCS_Data(
  Counts = rbind(counts, spikes),
  Tech = ind_spike,
  SpikeInfo = spike_input,
  BatchInfo = sce_naive$Individuals
)
data_naive
```

Alternatively, when using datasets that contain spike-in genes, the 
original `SingleCellExperiment` object can be extended by simply specifying a 
`BatchInfo` slot in the `colData` object and by adding the `SpikeInfo` object 
to the `metadata` slot.

```{r Data-naive-alternative}
data_naive <- sce_naive
colData(data_naive)$BatchInfo <- colData(sce_naive)$Individuals
metadata(data_naive)$SpikeInput <- spike_input
```

After creating the `SingleCellExperiment` object that contains all information 
that `BASiCS` requires, the MCMC sampler can be run to generate posterior 
estimates of model parameters.

### Running MCMC

It is recommended to run the `BASiCS_MCMC` sampler for at least 40,000 
iterations to ensure convergence.
However, if datasets are large and each condition contains hundreds of cells 
from a homogeneous population, BASiCS can be run with fewer (e.g. 20,000) 
iterations (see [10X Genomics data](#droplet-data)).
For convenience, `BASiCS_MCMC` can be run with very few (e.g 1,000) 
iterations to test whether the sampler breaks.
<!-- what do we mean by "breaks"? -->

Here, we run the MCMC sampler for 40,000 iterations, discaring the initial 
20,000 samples as burn-in, and using thinning factor of 20,
such that only each 20^th sample is stored for later use.
Since the dataset contains spike-in genes, we run the sampler with 
`WithSpikes = TRUE` and we also want to correct for the mean-variance trend 
using `Regression = TRUE`. For further information see [Methods](#methods).

```{r MCMC-naive, eval = FALSE}
MCMC_naive <- BASiCS_MCMC(
  Data = data_naive,
  PrintProgress = FALSE,
  N = 40000,
  Thin = 20,
  Burn = 20000,
  Regression = TRUE,
  WithSpikes = TRUE
)
```

This sampler runs for *167 minutes* on a 1.4 GHz Intel Core i5 procesor with 4GB
RAM and produces a `BASiCS_Chain` data object.
For comparison, this sampler runs for *97 minutes* on a 3.4 GHz Intel Core 
i7 procesor with 16GB RAM.
For convenience, the MCMC chain can be obtained online at 
[https://git.ecdf.ed.ac.uk/vallejosgroup/basicsworkflow2020](https://git.ecdf.ed.ac.uk/vallejosgroup/basicsworkflow2020).

```{r download-chain-naive}
download_file(
  file = "MCMC_naive.rds",
  website = "https://git.ecdf.ed.ac.uk/vallejosgroup/",
  folder = "basicsworkflow2020/raw/master/MCMCs/",
  destfile = "rds/MCMC_naive.rds"
)

MCMC_naive <- readRDS("rds/MCMC_naive.rds")
```

The `BASiCS_Chain` object contains a list of matrices that store the 
individual MCMC samples per parameter. Each matrix contains the cell- or 
gene-specific parameters in the columns and the MCMC samples in the rows.
`BASiCS` provides the `displayChainBASiCS` function to access the cell- or 
gene-specific parameters.
As an example, we access the first 2 samples for $\mu_i$ of the first 5 genes.

```{r displayChainBASiCS}
displayChainBASiCS(MCMC_naive, Param = "mu")[1:2, 1:5]
```

Given that we ran the MCMC samples for 40,000 iterations, discarding
the first 20,000 samples as burn-in, and using a thining factor of 20,
we obtained 1000 draws for each parameter, stored in the `BASiCS_Chain` object:

```{r dim-displayChainBASiCS}
dim(displayChainBASiCS(MCMC_naive, Param = "mu"))
```

### Assessing MCMC convergence {#naive-convergence}

In the next step, we need to assess the convergence of the chain to ensure 
robust downstream analysis. Specifically, we want to ensure that the chain
converged to its stationary distribution before the burn-in period ended,
and after burn-in that it sampled efficiently from this stationary distribution.
There are multiple ways to visualise and assess the convergence of MCMC chains
[@CowlesCarlin1996; @BrooksGelman1998]. The `r CRANpkg("coda")`
contains diagnostic and plot functions for this task ([@CODA2006]).

Here, we highlight two ways of assessing the convergence of the MCMC sampler by 
(i) plotting trace plots, sample densities and autocorrelation, and 
(ii) plotting the the effective sample size across multiple parameters.
Trace plots show the sampled parameter values over time. A chain is likely to
have converged when the sample density (in form of a histogram) shows a unimodal
distribution. The autocorrelation of an MCMC chain is defined as the Pearson 
correlation between the chain and time-delayed versions of the chain. 
The difference in time-points is referred to as 'lag'. This helps to assess
whether a chain has sampled efficiently from its stationary distribution.
High autocorrelation indicates that the obtained samples are not independent,
and indicates that we may not have enough information about the posterior
distribution of the parameters. The chain is likely to be sampling efficiently
if the autocorrelation (except for lag = 1) is small (e.g. < 0.25), as it 
indicates that the stored samples are largely independent.

Effective sample size is a measure of the number of independent samples 
generated for a model parameter [@Gelman2014]. Simply, it is defined as the 
number of samples taken relative to the total autocorrelation.
More formally, it is defined as follows:
$$
  \mbox{ESS} = \frac{n}{1 + 2\sum_{k=1}^\infty \rho(k)}
$$
where $n$ is the number of samples and $\rho(k)$ is the autocorrelation at lag 
$k$. We can visualise this parameter by plotting histograms of the effective
sample size over all genes, and by plotting effective sample size against
mean expression or over-dispersion for all genes.

```{r convergence-naive}
# Convergence of mean expression parameters
# Trace plot, sample histogram and autocorrelation
plot(MCMC_naive, Param = "mu", Gene = 1)
plot(MCMC_naive, Param = "mu", Gene = 7216)

# Effective sample size
BASiCS_DiagPlot(MCMC_naive, Param = "mu")

# Histogram of sample size for mu, as some genes seem to have low values for mu.
BASiCS_DiagHist(MCMC_naive, Param = "mu")

# Convergence of over-dispersion parameters
# Trace plot, sample histogram and autocorrelation
plot(MCMC_naive, Param = "delta", Gene = 100)
plot(MCMC_naive, Param = "delta", Gene = 5000)

# Effective sample size
BASiCS_DiagPlot(MCMC_naive, Param = "delta")

# Convergence of residual over-dispersion parameters
# Trace plot, sample histogram and autocorrelation
plot(MCMC_naive, Param = "epsilon", Gene = 200)
plot(MCMC_naive, Param = "epsilon", Gene = 9000)

# Effective sample size
BASiCS_DiagPlot(MCMC_naive, Param = "epsilon")

# Convergence of mRNA capture efficiency parameters
# Trace plot, sample histogram and autocorrelation
plot(MCMC_naive, Param = "s", Cell = 10)
plot(MCMC_naive, Param = "s", Cell = 50)

# Effective sample size
BASiCS_DiagPlot(MCMC_naive, Param = "s")
```

We can see several genes show very low sample size for mu. We can identify 
these using `BASiCS_EffectiveSize`.

```{r low-ess-genes}

ess <- BASiCS_EffectiveSize(MCMC_naive, Param = "mu")
low_ess_genes <- names(ess[ess < 100])
hist(
  ess,
  breaks = "FD",
  main = "Effective sample size",
  xlab = "Effective sample size"
)
abline(v = 100, lty = "dashed", col = "grey60")
head(low_ess_genes)
```

Given that the sample has generated less than 100 independent 
samples for these genes, there may not be sufficient posterior information to 
reliably calculate differences in mean expression, and it would be appropriate 
to exclude these genes from downstream analysis. As we will see later,
`BASiCS_TestDE` automatically excludes these genes from tests of differential
expression.

## Downstream analysis

In this section, we will highlight the use of BASiCS when analysing 
cells of a single condition. This includes normalisation, variance decomposition, 
detection of highly and lowly variable genes, and the use of gene-specific 
parameters as interpretable variability measures.
Furthermore, we will compare the results in the individual steps with results 
obtained using the `Biocpkg("scran")`.

### Normalisation

Posterior estimates of cell-specific parameters can be used to normalise the 
data and correct for biases in mRNA content [@Vallejos2017].
To perform normalisation, BASiCS provides the `BASiCS_DenoisedCounts` and the 
`BASiCS_DenoisedRates` functions. These functions produce normalised expression
values, with technical variation removed. They differ in that the former returns
a denoise expression count, such that
$$
x^*_{ij} = \frac{ x_{ij} } {\hat{\phi}_j \hat{\nu}_j},
$$
represents a normalised and denoised expression count. 
The latter returns a rate, such that
$$
\Lambda_{ij} = \hat{\mu_i} \hat{\rho}_{ij}
$$
is the denoised expression rate for a cell and gene.
Both of these functions take the `SingleCellExperiment` and `BASiCS_Chain`
objects as inputs.

```{r normalisation-naive}
counts_denoised <- BASiCS_DenoisedCounts(Data = data_naive, Chain = MCMC_naive)
```

These normalised counts or rates can be further used for dimensionality 
reduction and clustering as explained elsewhere [@Lun2016;@Amezquita2019].
Alternatively, a 
dimensionality reduction scheme that operates directly on the count matrix could
be used [@Townes2019;@Lopez2018].

### Lowly and highly variable gene detection

BASiCS offers a function to select genes with large or small biological 
variance. If the MCMC sampler was run with `Regression = TRUE` (default), 
the `BASiCS_DetectHVG` and `BASiCS_DetectLVG` functions take the 
`BASiCS_Chain` object and a quantile threshold.
Using the residual over-disperison parameters, genes are ranked by their 
variability and the `BASiCS_DetectHVG` function selects (for example) the 
10% most highly variable genes (`PercentileThreshold = 0.9`).
Similarly, when detecting lowly variable genes, the `BASiCS_DetectLVG` selects 
the 10% most lowly variable genes (`PercentileThreshold = 0.1`).
The propability threshold for a gene showing higher variability than the 
percentile threshold is found by controling the EFDR to 10% (default).
<!-- todo: explain EFDR -->

```{r naive-HVG-LVG}
# Highly variable genes
HVG <- BASiCS_DetectHVG(MCMC_naive, PercentileThreshold = 0.9)

# Lowly variable genes
LVG <- BASiCS_DetectLVG(MCMC_naive, PercentileThreshold = 0.1)
```

This analysis results in the detection of *`r sum(HVG$Table$HVG)`*
highly variable genes and *`r sum(LVG$Table$LVG)`*
lowly variable genes.

The `Biocpkg("scran")` provides similar functions to detect HVGs and we can 
compare the results of both methods.
`scran` first fits a smooth regression between the variance of the 
log-transformed expression of the spike-in transcripts and their mean 
abundance using the `trendVar` function.
Afterwards, the `decomposeVar` function decomposes the gene-specific variance 
into a biological and technical component.

```{r HVG-LVG-scran}
# Fit the mean-variance trend
means <- rowMeans(logcounts(sce_naive))
vars <- rowVars(logcounts(sce_naive))
var_fit <- scran::fitTrendVar(means, vars)

# Variance decomposition
var_out <- scran::modelGeneVar(sce_naive)
```

As proposed by `SimpleSingleCell` and by `OSCA`,
HVGs can be defined as those genes displaying a biolgical variance component of 
larger than 0.5, while controlling the FDR to 5% [@Lun2016;@Amezquita2019].
We can then compare the the overlap of the HVG identified by scran and by BASiCS.

```{r scran-HVG}
ind_hvg <- which(var_out$FDR <= 0.05 & var_out$bio >= 0.5)
hvg_out <- var_out[ind_hvg, ]
hvg_out <- hvg_out[order(hvg_out$bio, decreasing = TRUE), ]
nrow(hvg_out)

# Intersection between BASiCS and scran HVG
length(intersect(rownames(hvg_out), HVG$Table$GeneName[HVG$Table$HVG]))

# Compare BASiCS and scran results
HVG_res <- paste(
  HVG$Table$HVG, 
  var_out[HVG$Table$GeneName, "FDR"] <= 0.05 &
    var_out[HVG$Table$GeneName, "bio"] >= 0.5
)

ggplot() +
  geom_point(
    data = data.frame(
      Mu = HVG$Table$Mu,
      Epsilon = HVG$Table$Epsilon,
      HVG = HVG_res
    ),
    aes(log(Mu), Epsilon, colour = HVG)
  )
```

*`r length(intersect(rownames(hvg_out), HVG$Table$GeneName[HVG$Table$HVG]))`*
of the *`r nrow(hvg_out)`* HVGs of scran are among the
*`r sum(HVG$Table$HVG)`*
HVGs identified by BASiCS.

### Mean-variance trend

*TODO: Move this up* <!-- to where? -->

Numerous studies have highlighted the relationship between gene-specific 
variability measures (e.g., squared coefficient of variation) and mean 
abundance [@Ritchie2015;@Grun2014;@Love2014;@McCarthy2012].
BASiCS provides the `BASiCS_ShowFit` function that plots the gene-specific 
over-dispersion parameters (delta) versus mean expression parameters (mu). 

```{r naive-fit}
BASiCS_ShowFit(MCMC_naive)
```

Here, we observe that the over-dispersion estimates are inversely correlated
with mean expression.
However, by performing a regression between over-dispersion and mean 
expression, we can correct for this trend and obtain variability measures that 
show no correlation with mean expression [@Eling2018].
The purple points in the plot indicate genes that are not expressed in at least 
2 cells.
BASiCS automatically excludes these genes due to challenges in interpreting 
variability estimates and changes in variability for genes that are only 
expressed in one cell.

We can now compare these gene-specific variability measures (over-dispersion and 
residual over-dispersion) to previously used measures to quantify cell-to-cell 
expression variability [@Brennecke2013,@Kolodziejczyk2015cell].

### Comparison to variance, Fano factor, CV^2, and DM

Widely used measures of expression variability include the variance 
[@Shalek2014], the Fano factor (variance divided by mean expression) 
[@Wills2013;@Grun2014;@Arriaga2009] and 
the coefficient of variation (CV, variance divided by squared mean expression) 
[@Buettner2015;@Brennecke2013].
Here, we will highlight the mean-variance realtionship for each variability 
measures. For this analysis, we exclude genes that are not expressed in at 
least 2 cells.
These genes can be identified in the 
`displayChainBASiCS(MCMC_naive, Param = "epsilon")` to contain `NA`.

```{r variability-measures}
# Exclude ERCCs
counts_denoised <- counts_denoised[!grepl("ERCC", rownames(counts_denoised)), ]

# Exclude genes
eps_not_na <- !is.na(displayChainBASiCS(MCMC_naive, Param = "epsilon")[1, rownames(counts_denoised)])
counts_denoised <- counts_denoised[eps_not_na, ]

# Variance
var_genes <- apply(counts_denoised, 1, var)
mean_genes <- apply(counts_denoised, 1, mean)

ggplot(
    data.frame(
      variance = var_genes,
      mean = mean_genes
    )
  ) +
  geom_pointdensity(aes(log(mean), log(variance))) +
  scale_color_viridis()

# Fano factor
ggplot(
    data.frame(
      fano = var_genes / mean_genes,
      mean = mean_genes
    )
  ) +
  geom_pointdensity(aes(log(mean), log(fano))) +
  scale_color_viridis()

# Squared coefficient of variation
ggplot(
    data.frame(
      CV2 = var_genes / mean_genes^2,
      mean = mean_genes
    )
  ) +
  geom_pointdensity(aes(log(mean), log(CV2))) +
  scale_color_viridis()
```

We see that all measures correlate with mean expression.
The same is true for the over-dispersion parameters estimated by BASiCS, as
shown below. Again, for this comparison, we exclude genes that are not observed
to be expressed in at least 2 cells

```{r CV-comparison-BASiCS}
summary_naive <- Summary(MCMC_naive)
# Remove genes
eps_not_na <- !is.na(displaySummaryBASiCS(summary_naive, Param = "epsilon")[, "median"])
mu_naive <- displaySummaryBASiCS(summary_naive, Param = "mu")[eps_not_na, ]
delta_naive <- displaySummaryBASiCS(summary_naive, Param = "delta")[eps_not_na, ]

# Over-dispersion versus mean expression
ggplot(
    data.frame(
      mu = mu_naive[, "median"],
      delta = delta_naive[, "median"]
    )
  ) +
  geom_pointdensity(aes(log(mu), log(delta))) +
  scale_color_viridis()

# Compare delta to CV2
ggplot(
    data.frame(
      CV2 = var_genes / mean_genes^2,
      delta = delta_naive[rownames(counts_denoised), "median"]
    )
  ) +
  geom_pointdensity(aes(log(CV2), log(delta))) +
  scale_color_viridis()
```

The over-dispersion parameters estimated using BASiCS show strong correlation 
with CV^2. Recently, we extended BASiCS to avoid the mean-variability 
relationship by performing an internal regression between the over-dispersion 
and mean expression parameters (as visualised in figure *Figure showFit*).
Similarly, Kolodziejczyk _et al._ used the distance to a rolling median (DM) 
along the mean-variability trend to correct for this confounding factor 
[@Kolodziejczyk2015cell].
Here, we highlight how to obtain the residual variability estimates using 
`BASiCS` and `scran`.

```{r mean-dispersion-plots}
# Residual over-dispersion estimates
epsilon_naive <- displaySummaryBASiCS(summary_naive, Param = "epsilon")[eps_not_na, ]

# Residual over-dispersion versus mean expression
ggplot(
    data.frame(
      mu = mu_naive[, "median"],
      epsilon = epsilon_naive[, "median"]
    )
  ) +
  geom_pointdensity(aes(log(mu), epsilon)) +
  scale_color_viridis()

# DM values
DM.naive <- scran::DM(mean = mean_genes, cv2 = var_genes / mean_genes^2)

# DM versus mean expression
ggplot(
    data.frame(
      mean = mean_genes,
      DM = DM.naive
    )
  ) +
  geom_pointdensity(aes(log(mean), DM)) +
  scale_color_viridis()

# Compare residual over-dispersion and DM
ggplot(
    data.frame(
      epsilon = epsilon_naive[rownames(counts_denoised), "median"],
      DM = DM.naive
    )
  ) +
  geom_pointdensity(aes(epsilon, DM)) +
  scale_color_viridis()
```

Neither the DM nor the residual over-dispersion estimates show association 
with mean expression.
Furthermore, the mean-independent variability measures display high correlation.
These measures can be used to associate genomic features 
[@Morgan2018,@Faure2017] or transcriptional dynamics [@Antolovic2017] to 
gene expression variability.
While the DM is calculated as a point estimate, BASiCS stores each posterior 
sample within the `BASiCS_Chain` object.
They can be accessed using the `displayChain` function, which displays cell- 
or gene-specific samples in form of a matrix where each column contains cell- 
or gene-specific paramters and rows contain the MCMC samples.

```{r individual-samples}
displayChainBASiCS(MCMC_naive, Param = "epsilon")[1:10, 1:10]
```

<!-- **TODO: Not sure if we need this** why not? doesn't hurt imo -->
By testing a certain association (for example between CpG island length and 
variability [@Morgan2018]) for each MCMC sample, one can generate a _post-hoc_ 
posterior distribution of the test statistic. 

The workflow so far highlights the use of BASiCS for analysing cells of a 
single condition.

## Differential testing between naive and activated CD4^+^ T cells (two group example) {#Tcells-two}

This section highlights the use of BASiCS to perform differential testing 
(mean and variability) between cells of two condtions. 
For convenience, we will compare the naive CD4^+^ T cells, which were analysed 
in the previous section to activated CD4^+^ T cells of the same dataset 
[@Martinez-jimenez2017]. Naive CD4^+^ T cells were activated for 3 hours 
using plate-bound CD3e and CD28 antibodies.
T cell activation is linked to strong transcriptional shifts and the
up-regulation of lineage specific marker genes, such as Tbx21 and Gata1 
[@Best2013;@Fu2012].
To generate this data, the authors did not add cytokines, which are needed for 
T cell differentiation [@Zhu2010], meaning that any heterogeneity in the activated 
cell population does not arise from cells residing in different lineage-specific 
differentiation states. Prior to differential testing, and as explained above, 
we need to generate a `SingleCellExperiment` object that is compatible for
processing using `BASiCS`.

### Creating the BASiCS Data objects

We have performed quality control on the naive and activated CD4^+^ T cells 
above when [preparing the `BASiCS_Data` object](#Tcells-filtering).
Therefore, we can directly select the 
activated CD4^+^ T cells from the `sce_naive_active` object.

```{r SCE-active}
ind_active <- sce_naive_active$Stimulus == "Active"
sce_active <- sce_naive_active[, sce_naive_active$Stimulus == "Active"]
```

Similar to the procedure described above in the 
[single condition example](#Tcells-single), we will use 
the `newBASiCS_Data` function to re-generate the `SingleCellExperiment` object 
for the use with BASiCS.

```{r Data-active}
## select the biological genes of the dataset
counts <- counts(sce_active)
## Select the ERCC spike-ins of the dataset
spikes <- assay(altExp(sce_active, "spike-ins"))
spikes_present <- rowSums(spikes) != 0
## Remove spike-ins that are not present from matrix and SCE object
spikes <- spikes[spikes_present, ]
altexp_present <- altExp(sce_active, "spike-ins")[spikes_present, ]
altExp(sce_active, "spike-ins") <- altexp_present
ind_spike <- c(rep(FALSE, nrow(counts)), rep(TRUE, nrow(spikes)))
spike_input <- ERCC_count[rownames(spikes), ]


# Generate the SingleCellExperiment object
data_active <- newBASiCS_Data(
  Counts = rbind(counts, spikes),
  Tech = ind_spike,
  SpikeInfo = spike_input,
  BatchInfo = sce_active$Individuals
)

## Subset to common genes with naive
data_active <- data_active[rownames(data_naive)]
```

### Running the MCMC

We can use this `SingleCellExperiment` object as an input to `BASiCS_MCMC`
and run the MCMC sampler over 40,000 iterations.

```{r MCMC-active, eval = FALSE}
MCMC_active <- BASiCS_MCMC(
  Data = data_active,
  PrintProgress = FALSE,
  N = 40000,
  Thin = 20,
  Burn = 20000,
  Regression = TRUE,
  WithSpikes = TRUE
)
```

This sampler runs for *98 minutes* on a 1.4 GHz Intel Core i5 processor with 
4GB RAM and produces a `BASiCS_Chain` data object.
The same sampling run completed in *59 minutes* on a 3.4 GHz Intel Core i7 
processor with 16GB RAM.
For convenience, this MCMC chain can be again obtained online at 
[https://git.ecdf.ed.ac.uk/vallejosgroup/basicsworkflow2020/](https://git.ecdf.ed.ac.uk/vallejosgroup/basicsworkflow2020/).


```{r download-chain-active}
download_file(
  file = "MCMC_active.rds",
  website = "https://git.ecdf.ed.ac.uk/vallejosgroup/",
  folder = "basicsworkflow2020/raw/master/MCMCs/",
  destfile = "rds/MCMC_active.rds"
)
MCMC_active <- readRDS("rds/MCMC_active.rds")
```

### Quality checks

Similar to the `BASiCS_Chain` quality checks described above, we will again 
profile the convergence of the chain using a visual inspection of the trace 
plots, sample histograms and autocorrelation of individual chains.
Furthermore, we will use the `BASiCS_DiagPlot` function to assess the 
effective sample size of all chains per parameter class.

```{r convergence-active}
# Convergence of mean expression parameters
# Trace plot, sample histogram and autocorrelation
plot(MCMC_active, Param = "mu", Gene = 1)
plot(MCMC_active, Param = "mu", Gene = 1000)

# Effective sample size
BASiCS_DiagPlot(MCMC_active, Param = "mu")

# Histogram of effective sample size for mu, as some genes seem to have low values for mu.
BASiCS_DiagHist(MCMC_active, Param = "mu")

# Convergence of over-dispersion parameters
# Trace plot, sample histogram and autocorrelation
plot(MCMC_active, Param = "delta", Gene = 100)
plot(MCMC_active, Param = "delta", Gene = 5000)

# Effective sample size
BASiCS_DiagPlot(MCMC_active, Param = "delta")

# Convergence of residual over-dispersion parameters
# Trace plot, sample histogram and autocorrelation
plot(MCMC_active, Param = "epsilon", Gene = 200)
plot(MCMC_active, Param = "epsilon", Gene = 5000)

# Effective sample size
BASiCS_DiagPlot(MCMC_active, Param = "epsilon")

# Convergence of mRNA capture efficiency parameters
# Trace plot, sample histogram and autocorrelation
plot(MCMC_active, Param = "s", Cell = 10)
plot(MCMC_active, Param = "s", Cell = 50)

# Effective sample size
BASiCS_DiagPlot(MCMC_active, Param = "s")
```

To highlight the regression trend, we can use the `BASiCS_ShowFit` function.

```{r active-fit}
BASiCS_ShowFit(MCMC_active)
```

The MCMC sampler converged and the regression captured the full range of 
data points similar to the regression done on naive CD4^+^ T cells.
We can therefore move on to perform differential testing between naive and 
activated CD4^+^ T cells.

## Differential testing

```{r convergence-ess}
BASiCS_DiagHist(MCMC_active, Param = "mu")
BASiCS_DiagHist(MCMC_active, Param = "delta")

BASiCS_DiagPlot(MCMC_active, Param = "mu")
BASiCS_DiagPlot(MCMC_active, Param = "delta")
```

### Differential mean expression

To perform robust differential mean expression testing, BASiCS removes
genes with small effective sample size from EFDR calibration and 
differential expression testing.
As explained [above](#naive-convergence), BASiCS automatically excludes genes
with an effective sample size less than 100.

The default settings for differential mean expression testing are as follows:

- `EpsilonM`: Log~2~ fold change (LFC) threshold for changes in mean expression.
  Default value is $\log_2(1.5)\approx0.41$.
- `MinESS`: Minimum effective sample size for genes to be included in 
  differential tests. Default value is 100.
- `EFDR_M`: Expected false discovery rate: 10%
- `Plot`, `PlotOffset`: Boolean to control if results are plotted.
  Default value is TRUE for both.

```{r mean-expression-testing}

# Perform differential testing
Test_DE <- BASiCS_TestDE(
  Chain1 = MCMC_naive,
  Chain2 = MCMC_active,
  EpsilonM = log2(1.5),
  GroupLabel1 = "Naive",
  GroupLabel2 = "Active",
  Plot = FALSE,
  PlotOffset = FALSE,
  CheckESS = TRUE,
  MinESS = 100
)
```

After running the test, we can now visaulize the results in form of a MA-plot 
(log ratio _versus_ mean average) and volcano plot (posterior probability
_versus_ log ratio).

```{r visualise-MA-plot}
colour_map <- c(
  "Naive+" = "dark blue",
  "Active+" = "dark red",
  "NoDiff" = "black",
  "ExcludedLowESS" = "grey60",
  "ExcludedByUser" = "grey80"
)
Test_DE$TableMean$ResultDiffMean <- factor(
  Test_DE$TableMean$ResultDiffMean,
  levels = names(colour_map)
)
ord <- order(Test_DE$TableMean$ResultDiffMean, decreasing = TRUE)
Test_DE$TableMean <- Test_DE$TableMean[ord, ]
colour_scale <- scale_color_manual(values = colour_map)
# Visualise MA plot
ggplot(Test_DE$TableMean) +
  geom_point(
    aes(log(MeanOverall), MeanLog2FC, colour = ResultDiffMean),
    shape = 16,
    alpha = 0.5
  ) +
  colour_scale
# Visualise MA plot
ggplot(Test_DE$TableMean) +
  geom_point(
    aes(MeanLog2FC, ProbDiffMean, colour = ResultDiffMean),
    shape = 16,
    alpha = 0.5
  ) +
  colour_scale
```

**TODO: we can also plot this using BASiCS_PlotDE**


As we can see for the comparison of naive and activated CD4^+^ T cells, most 
genes show strong differences in mean expression.
In such cases, it can be beneficial to increase the LFC threshold or to 
decrease the threshold for the EFDR.
Here, we therfore set the LFC threshold to $\log_2(2)=1$ to detect genes 
with strong changes in mean expression. We also set `MinESS` to 100. This
causes genes with effective sample size less than 100 in either input chain
to be excluded from EFDR calibration and differential expression testing.


```{r mean-expression-testing-2}
# Perform differential testing
Test_DE <- BASiCS_TestDE(
  Chain1 = MCMC_naive,
  Chain2 = MCMC_active,
  EpsilonM = log2(2),
  GroupLabel1 = "Naive",
  GroupLabel2 = "Active",
  Plot = FALSE,
  PlotOffset = FALSE,
  CheckESS = TRUE,
  MinESS = 100
)
table(Test_DE$TableMean$ResultDiffMean)
```

In this case, this results in 
`r sum(Test_DE$TableMean$ResultDiffMean=="ExcludedLowESS")` genes with low 
effective sample size being excluded from differential mean expression tests
and `r sum(Test_DE$TableDisp$ResultDiffDisp=="ExcludedLowESS")`
genes being excluded from tests of differential over-dispersion.
To understand the regulatory programmes that underlie T cell activation, a 
variety of downstream analyses can be peformed using the differentially 
expressed genes.
Here, we highlight the use of gene ontology (GO) analysis to group genes that 
are differentially expressed between naive and activated CD4^+^ T cells.
For this, we use the Bioconductor `Biocpkg(goseq)` package and the 
`Biocpkg(org.Mm.eg.db)` annotation package to test GO enrichment within 
genes specifically expressed by naive or activated CD4^+^ T cells


```{r go-analysis-naive}
# Collect significan genes as 1 and all other as 0
naive_genes <- as.integer(Test_DE$TableMean$ResultDiffMean == "Naive+")
names(naive_genes) <- Test_DE$TableMean$GeneName

# Build a Null distribution by correcting the gene length bias
pwf <- nullp(naive_genes, "mm10", "ensGene",
  bias.data = genenames[names(naive_genes), "gene_length"]
)
GO_wall <- goseq(pwf, "mm10", "ensGene")
ind_signif <- p.adjust(GO_wall$over_represented_pvalue, method = "fdr") < 0.01
naive_GO <- DataFrame(GO_wall[ind_signif, ])

# Add genenames to the GO categories
all_genes <- vector(length = nrow(naive_GO))
for (i in 1:nrow(naive_GO)) {
  allegs <- get(naive_GO$category[i], org.Mm.egGO2ALLEGS)
  genes <- unique(unlist(mget(allegs, org.Mm.egENSEMBL)))
  genes <- as.character(intersect(
    genes,
    Test_DE$TableMean$GeneName[naive_genes == 1]
  ))
  all_genes[i] <- paste(genenames[genes, "external_gene_name"],
    collapse = ", "
  )
}
naive_GO$gene <- all_genes

# Show GO categories
head(naive_GO$term, n = 10)
```

Genes that are down-regulated during immune activation are enriched for cell
surface receptor signalling related categories.
This is in line with the well-known down-regulation of the T-cell receptor 
(TCR) complex upon activation [@Borroto2000].
Here, we find components of the TCR complex (such as _Cd28_, _Cd3e_, _Cd3g_,
_Cd4_; all part of the 'cell surface receptor signaling pathway' GO category) 
to show higher expression in naive cells compared to activated CD4^+^ T cells.

We can also test the enrichment of GO categories among genes that show 
increased expression upon T cell activation.

```{r go-analysis-active}
# Collect significan genes as 1 and all other as 0
active_genes <- as.integer(Test_DE$TableMean$ResultDiffMean == "Active+")
names(active_genes) <- Test_DE$TableMean$GeneName

# Build a Null distribution by correcting the gene length bias
pwf <- nullp(active_genes, "mm10", "ensGene",
  bias.data = genenames[names(active_genes), "gene_length"]
)
GO_wall <- goseq(pwf, "mm10", "ensGene")
ind_signif <- p.adjust(GO_wall$over_represented_pvalue, method = "fdr") < 0.01
active_GO <- DataFrame(GO_wall[ind_signif, ])

# Add genenames to the GO categories
all_genes <- vector(length = nrow(active_GO))
for (i in 1:nrow(active_GO)) {
  allegs <- get(active_GO$category[i], org.Mm.egGO2ALLEGS)
  genes <- unique(unlist(mget(allegs, org.Mm.egENSEMBL)))
  genes <- as.character(intersect(
    genes,
    Test_DE$TableMean$GeneName[active_genes == 1]
  ))
  all_genes[i] <- paste(genenames[genes, "external_gene_name"],
    collapse = ", "
  )
}
active_GO$gene <- all_genes

# Show GO categories
head(active_GO$term, n = 10)
```

Genes that are up-regulated upon activation are enriched for GO categories that
are associated with translational and metabolic processes. 
It has been shown that within the first 24 hours of T cell activation, cells 
start to up-regulate components involved in translation, ribosome biogenesis 
and profileration [@Tan2017;@Araki2017]. 
This signature can be recovered by performing differential mean expression 
analysis between naive and activated CD4^+^ T cells.

While other computational tools exist to perform differential mean expression
analysis, we next want to highlight the use of BASiCS for differential 
variability testing.

### Differential over-dispersion

Due to the negative association between over-dispersion and mean expression 
parameters, only genes that do not show a change in mean expression.
To avoid the confounding effect of mean expression, we perform differential 
testing by setting the LFC threshold on mean expression to `EpsilonM = 0`, while 
using the default LFC threshold on changes in over-dispersion: 
`EpsilonD = log2(1.5)`.
Furthermore, it is crucial to exclude lowly expressed genes from this 
analysis to avoid biases arising from non-informative genes showing only
low levels of stochastic expression.

```{r over-dispersion-testing}
# Select genes that show expression in both conditions
genes_select <- (Test_DE$TableMean$Mean1 > 1 & Test_DE$TableMean$Mean2 > 1)

Test_DE_LFC0 <- BASiCS_TestDE(
  Chain1 = MCMC_naive,
  Chain2 = MCMC_active,
  EpsilonM = 0,
  GroupLabel1 = "Naive",
  GroupLabel2 = "Active",
  Plot = FALSE,
  PlotOffset = FALSE,
  CheckESS = TRUE,
  MinESS = 100,
  GenesSelect = genes_select
)
```

We first select the genes that remain similarly expressed between both 
conditions and highlight the differential over-dispersion results in form of MA- 
and boxplots.

```{r over-dispersion-result}
# Select genes with no changes in mean expression
ind_nochange <- Test_DE_LFC0$TableMean$ResultDiffMean == "NoDiff"

# MA plot
ggplot(Test_DE_LFC0$TableDisp[ind_nochange, ]) +
  geom_point(
    aes(
      log(MeanOverall),
      DispLog2FC,
      colour = ResultDiffDisp
    ),
    shape = 16,
    alpha = 0.5
  ) +
  scale_color_manual(
    values = c(
      "Naive+" = "dark blue",
      "Active+" = "dark red",
      "NoDiff" = "black"
    )
  )

# Boxplot
wilcox.test(Test_DE_LFC0$TableDisp$DispLog2FC[ind_nochange])
boxplot(Test_DE_LFC0$TableDisp$DispLog2FC[ind_nochange],
  ylab = "LFC in over-dispersion", outline = FALSE
)
abline(a = 0, b = 0, lwd = 2, col = "dark red")

wilcox.test(Test_DE_LFC0$TableDisp$DispLog2FC[ind_nochange])
```

With this analysis, we detect increased over-dispersion in naive CD4^+^ T cells
for genes that show similar expression levels between naive and activated 
CD4^+^ T cells.

### Differential residual over-dispersion

While the analysis in the previous section is well suited to detect global 
changes in variability (e.g. detecting if one cell population overall displays
higher expression variabilty), it does not allow the testing of changes in 
mean expression and expression variability in parallel.
For this, BASiCS compares the residual over-dispersion parameters, which do 
not scale with mean expression, between the two conditions.
Here, we filter on genes that are lowly expressed in both conditions and, as 
explained above, remove genes for which the MCMC sampler obtained a low 
effective sample size:

```{r res-over-disp-filtering}
# Remove lowly expressed genes
low_expr <- !(Test_DE$TableMean$Mean1 < 1 & Test_DE$TableMean$Mean2 < 1)

# Genes to exclude
genes_select <- low_expr
```

We can now perform differential testing as shown above.
Again, we use a LFC threshold higher than the default to capture strong changes
in mean expression.

```{r DE-DV-testing}
# Perform differential testing
Test_DE <- BASiCS_TestDE(
  Chain1 = MCMC_naive,
  Chain2 = MCMC_active,
  EpsilonM = log2(2),
  GroupLabel1 = "Naive",
  GroupLabel2 = "Active",
  CheckESS = TRUE,
  MinESS = 100,
  Plot = FALSE,
  PlotOffset = FALSE,
  GenesSelect = genes_select
)
```

We can now visualise the changes in residual over-dispersion between naive and 
activated CD4^+^ T cells in the form of a MA-plot.
In this visualisation, the difference between the posterior medians of the 
residual over-dispersion parameters $\epsilon$ is shown on the y-axis.
Epsilon values for genes that are not expressed in at least 2 cells per 
conditions are marked as `NA` and are therefore not being displayed.

```{r diff-res-plot}
colour_map <- c(
  "Naive+" = "dark blue",
  "Active+" = "dark red",
  "NoDiff" = "black",
  "ExcludedByUser" = "grey",
  "ExcludedLowESS" = "grey80",
  "ExcludedFromTesting" = "grey50"
)
Test_DE$TableResDisp$ResultDiffResDisp <- factor(
  Test_DE$TableResDisp$ResultDiffResDisp,
  levels = names(colour_map)
)
ord <- order(Test_DE$TableResDisp$ResultDiffResDisp, decreasing = TRUE)
Test_DE$TableResDisp <- Test_DE$TableResDisp[ord, ]
ggplot(Test_DE$TableResDisp) +
  geom_point(
    aes(
      x = log(MeanOverall),
      y = ResDispDistance,
      colour = ResultDiffResDisp
    ),
    shape = 16,
    alpha = 0.5
  ) +
  scale_color_manual(values = colour_map)
```

While one could perform GO analysis (as explained above) on the genesets that 
change in residual over-dispersion, here, we want to highlight how to analyse 
changes in mean expression in parallel to changes in variability.
For this, we will first combine the results of the differential mean expression 
and the differential residual over-dispersion test.
We will further remove the genes that were excluded from the test and those 
that are not expressed in at least 2 cells in either condition.

```{r combine-results}
res_df <- cbind(Test_DE$TableMean, Test_DE$TableResDisp[, -c(1, 2)])
ind_exclude <- res_df$ResultDiffResDisp == "ExcludedByUser" |
  res_df$ResultDiffResDisp == "ExcludedFromTesting"
res_df <- res_df[!ind_exclude, ]
```

Next, we can visualise the regulation of each individual gene based on its 
changes in mean expression and expression variability.

```{r DV-DE-vis}
res_df$ResultDiffMean[grep("Excluded", res_df$ResultDiffMean)] <- "NoDiff"
res_df$ResultDiffResDisp[grep("Excluded", res_df$ResultDiffResDisp)] <- "NoDiff"
ggplot(res_df) +
  geom_point(
    aes(
      MeanLog2FC,
      ResDispDistance,
      colour = interaction(ResultDiffMean, ResultDiffResDisp, sep = ", ")
    ),
    alpha = 0.5,
    shape = 16
  ) +
  scale_color_brewer(name = "Categories", palette = "Set1") +
  labs(x = bquote(log[2](FC)), y = "Difference in residual over-dispersion")
```

While we can now test each of the nine genesets for functional enrichment, here, 
we are particularly interested in the set of genes that are up-regulated with 
increased variability upon immune activation.
Recently, it has been shown that specifically cytokines show heterogeneous 
expression in active immune cells and diverge between species [@Hagai2018].
We are therefore interested which immune response genes show variable activation 
patterns in early CD4^+^ T cell activation.
For this, we will first collect all immune response genes 
(GO category: `GO:0006955`) using the `goseq` package.

```{r variable-immune-response}
# Select immune response genes
immun_allegs <- get("GO:0006955", org.Mm.egGO2ALLEGS)
immun_genes <- unique(unlist(mget(immun_allegs, org.Mm.egENSEMBL)))
immun_names <- genenames[immun_genes, "external_gene_name"]
```

Finally, we will find the subset of immune response genes that are 
up-regulated and change in variability upon early immune activation.

```{r overlap}
# Variable response genes
ind_var_response <- res_df$ResultDiffMean == "Active+" &
  res_df$ResultDiffResDisp == "Active+"
var_response_genes <- genenames[
  res_df$GeneName[ind_var_response],
  "external_gene_name"
]
intersect(var_response_genes, immun_names)

ind_var_response <- res_df$ResultDiffMean == "Active+" &
  res_df$ResultDiffResDisp == "Naive+"
var_response_genes <- genenames[
  res_df$GeneName[ind_var_response],
  "external_gene_name"
]
intersect(var_response_genes, immun_names)
```

**TODO: what about these genes?** Pou2f2 and Smad3 .

While immune activation induces large transcriptional shifts in CD4^+^ T cells,
we will now exemplify the use of `BASiCS` on a system that shows more subtle
transcriptional changes during differentiation.




# Differential testing using differentiating cells (two group, droplet-based example) {#droplet-data}

With the development of droplet-based scRNA-seq [@Klein2015;@Macosko2015] 
lead to a strong increase in the number of cells that can be profiled per 
experiment. 
With this, large-scale scRNA-seq datasets have been generated to study 
development across multiple time-points and capturing multiple tissues 
[@Ibarra-Soria2018;@Kernfeld2018]. 
Here we describe the computational analysis of changes in mean expression 
and transcriptional variability when data is sparse and technical spike-in 
genes are missing. 
For this, we compare cells of the presomitic mesoderm and somitic mesoderm 
using droplet-based scRNA-seq data [@Ibarra-Soria2018].

## Obtaining the data

The full dataset is stored under the accession number E-MTAB-6153 on 
ArrayExpress and can be obtained via:

```{r load-droplet-data}
if (!file.exists("downloads/rawCounts.tsv")) {
  website <- "https://www.ebi.ac.uk/"
  folder <- "arrayexpress/files/E-MTAB-6153/"
  file <- "E-MTAB-6153.processed.2.zip"
  download.file(
    paste0(website, folder, file),
    destfile = "downloads/rawCounts.zip"
  )
  unzip(zipfile = "downloads/rawCounts.zip", exdir = "downloads")
  file.remove("downloads/rawCounts.zip")
}
rawCounts <- fread("downloads/rawCounts.tsv",
  sep = "\t", header = FALSE,
  data.table = FALSE
)

# Genenames are stored in first column
rownames(rawCounts) <- rawCounts[, 1]
rawCounts <- rawCounts[, -1]
```

*Of note:* The file is 65 MB in size while the unzipped, raw counts measure
873 MB in size.

The cluster labels of the original publication ca be obtained via:

```{r cluster-labels-droplet}
if (!file.exists("downloads/cellAnnotation.tsv")) {
  website <- "https://www.ebi.ac.uk/"
  folder <- "arrayexpress/files/E-MTAB-6153/"
  file <- "E-MTAB-6153.processed.3.zip"
  download.file(
    paste0(website, folder, file),
    destfile = "cluster_labels.zip"
  )
  unzip(zipfile = "cluster_labels.zip", exdir = "downloads")
}

cluster_labels <- read.table("downloads/cellAnnotation.tsv",
  sep = "\t", header = TRUE, stringsAsFactors = FALSE)
```

## Select populations of interest

We select the somitic and pre-somitic mesoderm cells to perform differential 
testing. Prior to running the MCMC, we want to control for outlying cells and 
heterogeneous substructure in both cell populations. 

```{r droplet-cell-selection, cache = FALSE}
cluster_labels[["Cell_type"]] <- cluster_labels$cellType
cluster_labels[["Cell_type"]] <- sub(
  "presomiticMesoderm",
  "PSM",
  cluster_labels[["Cell_type"]]
)
cluster_labels[["Cell_type"]] <- sub("somiticMesoderm",
  "SM", 
  cluster_labels[["Cell_type"]]
)

ind_som <- which(cluster_labels[["Cell_type"]] == "PSM" |
  cluster_labels[["Cell_type"]] == "SM")
rawCounts <- rawCounts[, ind_som]
cluster_labels <- cluster_labels[ind_som, ]
```

## Generating SingleCellExperiment object and quality control

For pre-processing and visualisation purposes, we load the data into a 
SingleCellExperiment object. The metadata will be stored in the `colData` slot.

```{r droplet-sce, cache = FALSE}
droplet_sce <- SingleCellExperiment(
  assays = list(counts = as(as.matrix(rawCounts), "dgCMatrix"))
)
rm(rawCounts)
colData(droplet_sce) <- DataFrame(
  cluster_labels,
  subCellType = sub("_.*", "", cluster_labels$cell)
)
```

For further processing steps, we remove lowly expressed genes.

```{r filter_drop}
ind_expressed <- Matrix::rowMeans(counts(droplet_sce)) > 0.1
droplet_sce <- droplet_sce[ind_expressed, ]
```

To visualise possible sub-structure in the data, we normalise both cell 
populations using the `scran` package.

```{r norm_drop}
droplet_sce <- computeSumFactors(droplet_sce,
  clusters = colData(droplet_sce)$subCellType
)
droplet_sce <- logNormCounts(droplet_sce)
```

Next, we compute a PCA using the `scater` package. 

```{r droplet_pca}
droplet_sce <- runPCA(droplet_sce)
```

We can now visualise the different factors stored in the `colData` slot.

```{r drop_pca_plot}
# Cell types identified by clustering
plotReducedDim(droplet_sce, dimred = "PCA", colour_by = "subCellType") +
  scale_fill_manual(name = "cellType", values = c("coral4", "steelblue", "limegreen"))
```

The first PC separates the two different cell types while the second PC captures
outlying cells.
We will remove these outliers and the intermediate cell population from 
down-stream analysis.

```{r drop_filt}
ind_retain <- reducedDims(droplet_sce)$PCA[, 2] > -5 &
  colData(droplet_sce)$subCellType != "presomiticMesoderm.b"
droplet_sce <- droplet_sce[, ind_retain]
```

We now collected the cells that we want to process using BASiCS. 
For this, we will generate the BASiCS data objects.

## Generating BASiCS data objects

Since droplet-based scRNA-seq data are generated without including technical 
spike-in genes, BASiCS uses measurement error models to quantify technical 
variation through replication [@Carroll1998].
Here, it is crucial to provide batch information to the BASiCS model.
In the case of the somitic and pre-somoitic mesoderm cells, embryos of two mice 
have been used to generate the data. 
Cells isolated from the first embryo were split into two batches and processed 
independently.
To capture cell-type extrinsic, biological variation between the two mice, we 
pool cells from the two batches of the first animal and only considere cells 
from mouse 1 and mouse 2 as replicates.

```{r BASiCS-droplet-data}
# Presomitic mesoderm
ind_presom <- colData(droplet_sce)[["Cell_type"]] == "PSM"
cur_counts <- droplet_sce[, ind_presom]
cur_batch <- round(colData(cur_counts)$sample, digits = 0)

PSM_Data <- newBASiCS_Data(
  Counts = as.matrix(counts(cur_counts)),
  Tech = rep(FALSE, nrow(droplet_sce)),
  SpikeInfo = NULL,
  BatchInfo = cur_batch
)

# Somitic mesoderm
ind_som <- colData(droplet_sce)[["Cell_type"]] == "SM"
cur_counts <- droplet_sce[, ind_som]
cur_batch <- round(colData(cur_counts)$sample, digits = 0)

SM_Data <- newBASiCS_Data(
  Counts = as.matrix(counts(cur_counts)),
  Tech = rep(FALSE, nrow(droplet_sce)),
  SpikeInfo = NULL,
  BatchInfo = cur_batch
)
```

## Running the MCMC

We next estimate model parameters by running the MCMC cell-type specifically. 
Due to the high cell number (1150 for the pre-somitic mesoderm and 739 for the 
somitic mesoderm), we set the number of iterations to 20000. 
In this case, we used the regression BASiCS model to additionally estimate residual 
over-dispersion parameters.

```{r, eval = FALSE}
# Presomitic mesoderm cells
PSM_MCMC <- BASiCS_MCMC(
  PSM_Data,
  N = 20000,
  Thin = 10,
  Burn = 10000,
  Regression = TRUE
)

# Somitic mesoderm cells
SM_MCMC <- BASiCS_MCMC(
  SM_Data,
  N = 20000,
  Thin = 10,
  Burn = 10000,
  Regression = TRUE
)
```

Running these MCMC will take around 8-12 hours on a standard PC (2.6 GHz i5,
8 GB RAM, using 1 core). Here, we provide these chains to download from:

```{r droplet-chain-download}
website <- "https://git.ecdf.ed.ac.uk/"
folder <- "vallejosgroup/basicsworkflow2020/raw/master/MCMCs/"
PSM_MCMC <- readRDS(
  file = url(
    paste0(website, folder, "PSM_MCMC.rds")
  )
)
SM_MCMC <- readRDS(
  file = url(
    paste0(website, folder, "SM_MCMC.rds")
  )
)
```

## Validating the model fit

Next, we visualise the results of the MCMC sampler by visualizing the 
different chains and by plotting the regression trend.
To assess whether the chains converged, we will visualise trace plots for some 
of the parameters. 
The `plot` function allows us to generate trace, posterior density,
and autocorrelation plots for different parameters.

```{r droplet-chain-convergence}
plot(PSM_MCMC, Param = "mu", Gene = 120)
plot(PSM_MCMC, Param = "delta", Gene = 10)
plot(PSM_MCMC, Param = "epsilon", Gene = 20)
plot(PSM_MCMC, Param = "s", Cell = 90)
plot(PSM_MCMC, Param = "nu", Cell = 100)
plot(PSM_MCMC, Param = "beta", RegressionTerm = 2)
plot(PSM_MCMC, Param = "sigma2", Column = 1)
plot(SM_MCMC, Param = "mu", Gene = 120)
plot(SM_MCMC, Param = "delta", Gene = 10)
plot(SM_MCMC, Param = "epsilon", Gene = 20)
plot(SM_MCMC, Param = "s", Cell = 90)
plot(SM_MCMC, Param = "nu", Cell = 100)
plot(SM_MCMC, Param = "beta", RegressionTerm = 2)
plot(SM_MCMC, Param = "sigma2")
```

We observe that the chains for all chosen parameters appear to have converged. 
Furthermore, to validate that the model fitted the mean-variability trend 
correctly, we plot posterior estimates for over-dispersion paramters $\delta_i$ 
against posterior estimates of mean expression parameters $\mu_i$.
For this, the `BASiCS_ShowFit` function can be used.

```{r droplet-regression-trend}
BASiCS_ShowFit(PSM_MCMC)
BASiCS_ShowFit(SM_MCMC)
```

Both trends display similar behaviour which allows us to compare residual 
over-dispersion estimates.

## Differential testing 

Next, we test for changes in mean expression and expression variability 
between the somitic and pre-somitic mesoderm.
First, we are interested in assessing global changes in expression 
variability between the two conditions.
For this, we compare over-dispersion parameters $\delta_i$ for genes that are
similarly expressed in both conditions.

```{r drop_testde_lfc0}
droplet_test_logFC0 <- BASiCS_TestDE(
  Chain1 = PSM_MCMC,
  Chain2 = SM_MCMC,
  EpsilonM = 0,
  GroupLabel1 = "PSM",
  GroupLabel2 = "SM",
  Plot = FALSE,
  PlotOffset = FALSE,
  CheckESS = TRUE,
  MinESS = 100
)
not_excluded <- droplet_test_logFC0$TableDisp$ResultDiffDisp != "ExcludedFromTesting"
for_plot <- droplet_test_logFC0$TableDisp[not_excluded, c("Disp1", "Disp2")]
for_plot <- reshape2::melt(for_plot)
ggplot(for_plot) + geom_boxplot(aes(variable, log(value))) +
  scale_x_discrete(labels = c("PSM", "SM")) +
  ylab("log(delta)") + xlab("")
```

### Global changes in variability

With this analysis, we do not detect global changes in expression variability.
We next profile changes in mean expression and expression variability on a 
gene-specific level.
For this, we use a log~2~ fold change threshold of 1 for mean expression testing 
and the default threshold of $\psi_0\approx0.41$ for differential variability 
testing.

```{r droplet-gene-specific-testing}
droplet_test <- BASiCS_TestDE(
  Chain1 = PSM_MCMC,
  Chain2 = SM_MCMC,
  EpsilonM = 1,
  GroupLabel1 = "PSM",
  GroupLabel2 = "SM",
  Plot = FALSE,
  PlotOffset = FALSE,
  CheckESS = TRUE,
  MinESS = 100
)


colour_map_sm <- c(
  "PSM+" = "dark blue",
  "SM+" = "dark red",
  "NoDiff" = "black",
  "ExcludedLowESS" = "grey60",
  "ExcludedByUser" = "grey80"
)

# Differential expression
ggplot(droplet_test$TableMean) +
  geom_point(
    aes(log(MeanOverall), MeanLog2FC, colour = ResultDiffMean),
    shape = 16,
    alpha = 0.5
  ) +
  scale_colour_manual(
    name = "Differential\nexpression",
    values = colour_map_sm
  ) +
  ylab(expression(mu[PSM] / mu[SM])) + xlab(expression(log(mu)))

# Differential variability
ggplot(droplet_test$TableResDisp) +
  geom_point(
    aes(log(MeanOverall), ResDispDistance, colour = ResultDiffResDisp),
    shape = 16,
    alpha = 0.5
  ) +
  scale_colour_manual(
    name = "Differential\nvariability",
    values = colour_map_sm
  ) +
  ylab(expression(epsilon[PSM] - epsilon[SM])) + xlab(expression(log(mu)))
```

### Differential mean expression

We can now list the genes that were detected as differentially expressed and 
differentially variable ordered by their difference in mean 
expression/variability.
We first focus on genes that are differentially expressed between the two cell 
types.

```{r gene-lists-mean}
# Highly expressed in somitic mesoderm
ind_sm <- droplet_test$TableMean$ResultDiffMean == "SM+"
SM_mean <- droplet_test$TableMean[ind_sm, ]
SM_mean <- SM_mean[order(SM_mean$MeanLog2FC, decreasing = FALSE), ]
SM_mean$Symbol <- genenames[SM_mean$GeneName, 2]

# Highly expressed in pre-somitic mesoderm
ind_psm <- droplet_test$TableMean$ResultDiffMean == "PSM+"
PSM_mean <- droplet_test$TableMean[ind_psm, ]
PSM_mean <- PSM_mean[order(PSM_mean$MeanLog2FC, decreasing = TRUE), ]
PSM_mean$Symbol <- genenames[PSM_mean$GeneName, 2]
```

We can next perform GO analysis on up- or down-regulated genes. 
First, we will perform GO analysis on somitic mesoderm specific genes.

```{r GO-analysis-mean-SM}
# Collect significan genes as 1 and all other as 0
SM_genes <- as.integer(droplet_test$TableMean$ResultDiffMean == "SM+")
names(SM_genes) <- droplet_test$TableMean$GeneName

# Build a Null distribution by correcting the gene length bias
pwf <- nullp(SM_genes, "mm10", "ensGene", bias.data = genelength[names(SM_genes)])
GO_wall <- goseq(pwf, "mm10", "ensGene")
ind_signif <- p.adjust(GO_wall$over_represented_pvalue, method = "fdr") < 0.01
SM_GO <- DataFrame(GO_wall[ind_signif, ])

# Add genenames to the GO categories
all_genes <- vector(length = nrow(SM_GO))
for (j in 1:nrow(SM_GO)) {
  allegs <- get(SM_GO$category[j], org.Mm.eg.db::org.Mm.egGO2ALLEGS)
  genes <- unique(unlist(mget(allegs, org.Mm.eg.db::org.Mm.egENSEMBL)))
  genes <- as.character(intersect(genes, SM_mean$GeneName))
  all_genes[j] <- paste(genes, collapse = ", ")
}
SM_GO$Genes <- all_genes
```

Now, we perform GO analysis on pre-somitic mesoderm specific genes

```{r GO-analysis-mean-PSM}
# Collect significan genes as 1 and all other as 0
PSM_genes <- as.integer(droplet_test$TableMean$ResultDiffMean == "PSM+")
names(PSM_genes) <- droplet_test$TableMean$GeneName

# Build a Null distribution by correcting the gene length bias
pwf <- nullp(
  PSM_genes,
  "mm10",
  "ensGene",
  bias.data = genelength[names(PSM_genes)]
)
GO_wall <- goseq(pwf, "mm10", "ensGene")
ind_signif <- p.adjust(GO_wall$over_represented_pvalue, method = "fdr") < 0.01
PSM_GO <- DataFrame(GO_wall[ind_signif, ])

# Add genenames to the GO categories
all_genes <- vector(length = nrow(PSM_GO))
for (j in 1:nrow(PSM_GO)) {
  allegs <- get(PSM_GO$category[j], org.Mm.eg.db::org.Mm.egGO2ALLEGS)
  genes <- unique(unlist(mget(allegs, org.Mm.eg.db::org.Mm.egENSEMBL)))
  genes <- as.character(intersect(genes, PSM_mean$GeneName))
  all_genes[j] <- paste(genes, collapse = ", ")
}
PSM_GO$Genes <- all_genes
```

To visualise the expression of individual genes, we can use the `scater` package.

```{r plot-de-scater}
celltype_color <- c(SM = "coral4", PSM = "limegreen")
# Expression of Fgf8 in both conditions
ind_fgf <- genenames$external_gene_name == "Fgf8"
plotExpression(droplet_sce,
  features = genenames[ind_fgf, 1],
  x = "Cell_type", colour_by = "Cell_type"
) + scale_fill_manual(name = "Cell type", values = celltype_color)
plotReducedDim(droplet_sce,
  dimred = "PCA",
  colour_by = genenames[ind_fgf, 1]
)
```

We can also visualise one GO category in form of heatmap.

```{r gp-heatmap, fig.height = 7, fig.width = 5, cache = FALSE}
genes <- unlist(strsplit(PSM_GO[1, "Genes"], ", "))
for_heatmap <- logcounts(droplet_sce)[genes, ]
colnames(for_heatmap) <- colData(droplet_sce)$cell

# Order cells by cell type
for_heatmap <- for_heatmap[, order(colnames(for_heatmap))]

# Order rows by log2FC
heatmap_ind <- match(rownames(for_heatmap), PSM_mean$GeneName)
heatmap_order <- order(PSM_mean[heatmap_ind, "MeanLog2FC"], decreasing = TRUE)
for_heatmap <- for_heatmap[heatmap_order, ]
rownames(for_heatmap) <- genenames[rownames(for_heatmap), 2]

celltypes <- sub("_.*", "", colnames(for_heatmap))
celltypes <- sub("presomiticMesoderm.a", "PSM", celltypes)
celltypes <- sub("somiticMesoderm", "SM", celltypes)

h <- Heatmap(as.matrix(for_heatmap),
  cluster_columns = FALSE,
  show_column_names = FALSE,
  cluster_rows = FALSE,
  # col = colorRampPalette(c("#053061", "#1B5484", "white", "#932631", "#67001f"))(100),
  col = viridis(100),
  row_names_gp = gpar(fontsize = 7),
  name = "\n\nNormalised\nexpression",
  top_annotation = columnAnnotation(
    `Cell type` = celltypes,
    col = list(`Cell type` = celltype_color)
  )
)
draw(h, merge_legend = TRUE)
```


### Differential variability testing

Next, we are interested in genes that change in variability between the two 
cell types. To help interpretion of the result, we will split the genes into 
four categories. These include:

* More variable in SM, highly expressed in SM
* More variable in SM, lowly expressed in SM
* More variable in PSM, highly expressed in PSM
* More variable in PSM, lowly expressed in SM

```{r diff-var-check}
gene_groups <- data.frame(
  Genename = droplet_test$TableResDisp$GeneName,
  Symbol = genenames[droplet_test$TableResDisp$GeneName, 2],
  MeanLog2FC = droplet_test$TableMean$MeanLog2FC,
  ResDispDistance = droplet_test$TableResDisp$ResDispDistance,
  Regulation = paste(
    droplet_test$TableMean$ResultDiffMean,
    droplet_test$TableResDisp$ResultDiffResDisp,
    sep = "_"
  )
)

ind_reg <- gene_groups$Regulation %in% c("SM+_SM+", "SM+_PSM+", "PSM+_PSM+", "PSM+_SM+")
gene_groups <- gene_groups[ind_reg, ]

knitr::kable(head(gene_groups[gene_groups$Regulation == "SM+_SM+", ]))
```

We can visualise individual genes using `scater`.

```{r violin-plots}
# Expression of Meox2 in both conditions
ind_meox <- genenames$external_gene_name == "Meox2"
plotExpression(droplet_sce,
  features = genenames[ind_meox, 1],
  x = "Cell_type", colour_by = "Cell_type"
) + scale_fill_manual(name = "Cell type", values = celltype_color)
plotReducedDim(droplet_sce,
  dimred = "PCA",
  colour_by = genenames[ind_meox, 1]
)
```

# Discussion 
This section is required if the paper does not include novel data or analyses.
It allows authors to briefly summarize the key points from the article.

# Session Info {#session-info}

```{r, session-info}
devtools::session_info()
```

# Software version

**TODO: Versions of all main Bioconductor packages**
*I think sessionInfo suffices.*



# Data availability

**TODO: Links to Grun data and Ximenas data**
**TODO: Links to MCMC chains**


# Software availability

**TODO: Software: All software used in this workflow is available as part of 
Bioconductor X.Y**
**TODO: The source code of this workflow is available from: YYY**
**TODO: Link to Github release version, source code**
**TODO: License: ask Aaron**

This section will be generated by the Editorial Office before publication. 
Authors are asked to provide some initial information to assist the 
Editorial Office, as detailed below.

1. URL link to where the software can be downloaded from or used by a non-coder
  (AUTHOR TO PROVIDE; optional)
2. URL link to the author's version control system repository containing the 
  source code (AUTHOR TO PROVIDE; required)
3. Link to source code as at time of publication (*F1000Research* TO GENERATE)
4. Link to archived source code as at time of publication (*F1000Research* 
  TO GENERATE)
5. Software license (AUTHOR TO PROVIDE; required)


# Author information
In order to give appropriate credit to each author of an article, the 
individual contributions of each author to the manuscript should be detailed in 
this section. We recommend using author initials and then stating briefly how 
they contributed.

# Competing interests

'No competing interests were disclosed'.

<!-- All financial, personal, or professional competing interests for any of the 
authors that could be construed to unduly influence the content of the article 
must be disclosed and will be displayed alongside the article. If there are no 
relevant competing interests to declare, please add the following: 
 -->

# Grant information
Please state who funded the work discussed in this article, whether it is your 
employer, a grant funder etc. Please do not list funding that you have that is 
not relevant to this specific piece of research. For each funder, please state 
the funder’s name, the grant number where applicable, and the individual to 
whom the grant was assigned. If your work was not funded by any grants, 
please include the line: 'The author(s) declared that no grants were involved 
in supporting this work.'

# Acknowledgments
This section should acknowledge anyone who contributed to the research or the 
article but who does not qualify as an author based on the criteria provided 
earlier (e.g. someone or an organization that provided writing assistance). 
Please state how they contributed; authors should obtain permission to 
acknowledge from all those mentioned in the Acknowledgments section.

Please do not list grant funding in this section.
